<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: ruby | VF svp]]></title>
  <link href="http://vfsvp.fr/tags/ruby/atom.xml" rel="self"/>
  <link href="http://vfsvp.fr/"/>
  <updated>2013-10-03T13:18:24+02:00</updated>
  <id>http://vfsvp.fr/</id>
  <author>
    <name><![CDATA[Simon Courtois (simonc)]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Les méthodes pack et unpack en Ruby]]></title>
    <link href="http://vfsvp.fr/article/les-methodes-pack-et-unpack-en-ruby"/>
    <updated>2013-10-03T12:56:00+02:00</updated>
    <id>http://vfsvp.fr/article/les-methodes-pack-et-unpack-en-ruby</id>
    <content type="html"><![CDATA[<p>C programming language allows developers to directly access the memory where variables are stored. Ruby does not allow that. There are times while working in Ruby when you need to access the underlying bits and bytes. Ruby provides two methods pack and unpack for that.</p>

<p>Here is an example.</p>

<p>``` ruby
&lsquo;A&rsquo;.unpack(&lsquo;b*&rsquo;)</p>

<h1>=> [&ldquo;10000010&rdquo;]</h1>

<p>```</p>

<p>In the above case ‘A’ is a string which is being stored and using unpack I am trying to read the bit value. The ASCII table says that ASCII valule of ‘A’ is 65 and the binary representation of 65 is 10000010 .</p>

<p>Here is another example.</p>

<p>``` ruby
&lsquo;A&rsquo;.unpack(&lsquo;B*&rsquo;)</p>

<h1>=> [&ldquo;01000001&rdquo;]</h1>

<p>```</p>

<p>Notice the difference in result from the first case. What’s the difference between b<em> and B</em>. In order to understand the difference first lets discuss MSB and LSB.</p>

<h2>Most significant bit vs Least significant bit</h2>

<p>All bits are not created equal. C has ascii value of 67. The binary value of 67 is 1000011.</p>

<p>First let’s discuss MSB (most significant bit) style . If you are following MSB style then going from left to right (and you always go from left to right) then the most significant bit will come first. Because the most significant bit comes first we can pad an additional zero to the left to make the number of bits eight. After adding an additional zero to the left the binary value looks like 01000011.</p>

<p>If we want to convert this value in the LSB (Least Significant Bit) style then we need to store the least significant bit first going from left to right. Given below is how the bits will be moved if we are converting from MSB to LSB. Note that in the below case position 1 is being referred to the leftmost bit.</p>

<p>move value 1 from position 8 of MSB to position 1 of LSB
move value 1 from position 7 of MSB to position 2 of LSB
move value 0 from position 6 of MSB to position 3 of LSB
and so on and so forth</p>

<p>After the exercise is over the value will look like 11000010.</p>

<p>We did this exercise manually to understand the difference between most significant bit and least significant bit. However unpack method can directly give the result in both MSB and LSB. The unpack method can take both b<em> and B</em> as the input. As per the ruby documentation here is the differnce.</p>

<p>B | bit string (MSB first)
b | bit string (LSB first)</p>

<p>Now let’s take a look at two examples.</p>

<p>``` ruby
&lsquo;C&rsquo;.unpack(&lsquo;b*&rsquo;)</p>

<h1>=> [&ldquo;11000010&rdquo;]</h1>

<p>```</p>

<p>``` ruby
&lsquo;C&rsquo;.unpack(&lsquo;B*&rsquo;)</p>

<h1>=> [&ldquo;01000011&rdquo;]</h1>

<p>```</p>

<p>Both b<em> and B</em> are looking at the same underlying data. It’s just that they represent the data differently.</p>

<h2>Different ways of getting the same data</h2>

<p>Let’s say that I want binary value for string hello . Based on the discussion in the last section that should be easy now.</p>

<p>``` ruby
&ldquo;hello&rdquo;.unpack(&lsquo;B*&rsquo;)</p>

<h1>=> [&ldquo;0110100001100101011011000110110001101111&rdquo;]</h1>

<p>```</p>

<p>The same information can also be derived as</p>

<p>``` ruby
&ldquo;hello&rdquo;.unpack(&lsquo;C*&rsquo;).map {|e| e.to_s 2}</p>

<h1>=> [&ldquo;1101000&rdquo;, &ldquo;1100101&rdquo;, &ldquo;1101100&rdquo;, &ldquo;1101100&rdquo;, &ldquo;1101111&rdquo;]</h1>

<p>```</p>

<p>Let’s break down the previous statement in small steps.</p>

<p>``` ruby
&ldquo;hello&rdquo;.unpack(&lsquo;C*&rsquo;)</p>

<h1>=> [104, 101, 108, 108, 111]</h1>

<p>```</p>

<p>Directive C* gives the 8-bit unsigned integer value of the character. Note that ascii value of h is 104, ascii value of e is 101 and so on.</p>

<p>Using the technique discussed above I can find hex value of the string.</p>

<p>``` ruby
&ldquo;hello&rdquo;.unpack(&lsquo;C*&rsquo;).map {|e| e.to_s 16}</p>

<h1>=> [&ldquo;68&rdquo;, &ldquo;65&rdquo;, &ldquo;6c&rdquo;, &ldquo;6c&rdquo;, &ldquo;6f&rdquo;]</h1>

<p>```</p>

<p>Hex value can also be achieved directly.</p>

<p>``` ruby
&ldquo;hello&rdquo;.unpack(&lsquo;H*&rsquo;)</p>

<h1>=> [&ldquo;68656c6c6f&rdquo;]</h1>

<p>```</p>

<h2>High nibble first vs Low nibble first</h2>

<p>Notice the difference in the below two cases.</p>

<p>``` ruby
&ldquo;hello&rdquo;.unpack(&lsquo;H*&rsquo;)</p>

<h1>=> [&ldquo;68656c6c6f&rdquo;]</h1>

<p>```</p>

<p>``` ruby
&ldquo;hello&rdquo;.unpack(&lsquo;h*&rsquo;)</p>

<h1>=> [&ldquo;8656c6c6f6&rdquo;]</h1>

<p>```</p>

<p>As per ruby documentation for unpack</p>

<p>H | hex string (high nibble first)
h | hex string (low nibble first)</p>

<p>A byte consists of 8 bits. A nibble consists of 4 bits. So a byte has two nibbles. The ascii value of ‘h’ is 104. Hex value of 104 is 68. This 68 is stored in two nibbles. First nibble, meaning 4 bits, contain the value 6 and the second nibble contains the value 8. In general we deal with high nibble first and going from left to right we pick the value 6 and then 8.</p>

<p>However if you are dealing with low nibble first then low nibble value 8 will take the first slot and then 6 will come. Hence the result in “low nibble first” mode will be 86.</p>

<p>This pattern is repeated for each byte. And because of that a hex value of 68 65 6c 6c 6f looks like 86 56 c6 c6 f6 in low nibble first format.</p>

<h2>Mix and match directives</h2>

<p>In all the previous examples I used *. And a * means to keep going as long as it has to keep going. Lets see a few examples.</p>

<p>A single C will get a single byte.</p>

<p>``` ruby
&ldquo;hello&rdquo;.unpack(&lsquo;C&rsquo;)</p>

<h1>=> [104]</h1>

<p>```</p>

<p>You can add more Cs if you like.</p>

<p>``` ruby
&ldquo;hello&rdquo;.unpack(&lsquo;CC&rsquo;)</p>

<h1>=> [104, 101]</h1>

<p>```</p>

<p>``` ruby
&ldquo;hello&rdquo;.unpack(&lsquo;CCC&rsquo;)</p>

<h1>=> [104, 101, 108]</h1>

<p>```</p>

<p>``` ruby
&ldquo;hello&rdquo;.unpack(&lsquo;CCCCC&rsquo;)</p>

<h1>=> [104, 101, 108, 108, 111]</h1>

<p>```</p>

<p>Rather than repeating all those directives, I can put a number to denote how many times you want previous directive to be repeated.</p>

<p>``` ruby
&ldquo;hello&rdquo;.unpack(&lsquo;C5&rsquo;)</p>

<h1>=> [104, 101, 108, 108, 111]</h1>

<p>```</p>

<p>I can use * to capture al the remaining bytes.</p>

<p>``` ruby
&ldquo;hello&rdquo;.unpack(&lsquo;C*&rsquo;)</p>

<h1>=> [104, 101, 108, 108, 111]</h1>

<p>```</p>

<p>Below is an example where MSB and LSB are being mixed.</p>

<p>``` ruby
&ldquo;aa&rdquo;.unpack(&lsquo;b8B8&rsquo;)</p>

<h1>=> [&ldquo;10000110&rdquo;, &ldquo;01100001&rdquo;]</h1>

<p>```</p>

<h2>pack is reverse of unpack</h2>

<p>Method pack is used to read the stored data. Let’s discuss a few examples.</p>

<p>``` ruby
 [1000001].pack(&lsquo;C&rsquo;)</p>

<h1>=> &ldquo;A&rdquo;</h1>

<p>```</p>

<p>In the above case the binary value is being interpreted as 8 bit unsigned integer and the result is ‘A’.</p>

<p>``` ruby
[&lsquo;A&rsquo;].pack(&lsquo;H&rsquo;)</p>

<h1>=> &ldquo;\xA0&rdquo;</h1>

<p>```</p>

<p>In the above case the input ‘A’ is not ASCII ‘A’ but the hex ‘A’. Why is it hex ‘A’. It is hex ‘A’ because the directive ‘H’ is telling pack to treat input value as hex value. Since ‘H’ is high nibble first and since the input has only one nibble then that means the second nibble is zero. So the input changes from [&lsquo;A&rsquo;] to [&lsquo;A0&rsquo;] .</p>

<p>Since hex value A0 does not translate into anything in the ASCII table the final output is left as it and hence the result is \xA0. The leading \x indicates that the value is hex value.</p>

<p>Notice the in hex notation A is same as a. So in the above example I can replace A with a and the result should not change. Let’s try that.</p>

<p>``` ruby
[&lsquo;a&rsquo;].pack(&lsquo;H&rsquo;)</p>

<h1>=> &ldquo;\xA0&rdquo;</h1>

<p>```</p>

<p>Let’s discuss another example.</p>

<p>``` ruby
[&lsquo;a&rsquo;].pack(&lsquo;h&rsquo;)</p>

<h1>=> &ldquo;\n&rdquo;</h1>

<p>```</p>

<p>In the above example notice the change. I changed directive from H to h. Since h means low nibble first and since the input has only one nibble the value of low nibble becomes zero and the input value is treated as high nibble value. That means value changes from [&lsquo;a&rsquo;] to [&lsquo;0a&rsquo;]. And the output will be \x0A. If you look at ASCII table then hex value A is ASCII value 10 which is NL line feed, new line. Hence we see \n as the output because it represents “new line feed”.</p>

<h2>Usage of unpack in Rails source code</h2>

<p>I did a quick grep in Rails source code and found following usage of unpack.</p>

<p>email_address_obfuscated.unpack(&lsquo;C<em>&rsquo;)
&lsquo;mailto:&rsquo;.unpack(&lsquo;C</em>&rsquo;)
email_address.unpack(&lsquo;C<em>&rsquo;)
char.unpack(&lsquo;H2&rsquo;)
column.class.string_to_binary(value).unpack(&ldquo;H</em>&rdquo;)
data.unpack(&ldquo;m&rdquo;)
s.unpack(&ldquo;U*&rdquo;)</p>

<p>Already we have seen the usage of directive C<em> and H for unpack. The directive m gives the base64 encoded value and the directive U</em> gives the UTF-8 character. Here is an example.</p>

<p>``` ruby
&ldquo;Hello&rdquo;.unpack(&lsquo;U*&rsquo;)</p>

<h1>=> [72, 101, 108, 108, 111]</h1>

<p>```</p>

<h2>Tested with</h2>

<p>Above code was tested with ruby 1.9.2.</p>
]]></content>
  </entry>
  
</feed>
