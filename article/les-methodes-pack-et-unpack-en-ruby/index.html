
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Les méthodes pack et unpack en Ruby - VF svp</title>
  <meta name="author" content="Simon Courtois (simonc)">

  
  <meta name="description" content="C programming language allows developers to directly access the memory where variables are stored. Ruby does not allow that. There are times while &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://vfsvp.fr/article/les-methodes-pack-et-unpack-en-ruby">
  <link href="/favicon.ico" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="VF svp" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">VF svp</a></h1>
  
    <h2>En français dans le texte</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="Suivre via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:vfsvp.fr" />
    <input class="search" type="text" name="q" results="0" placeholder="Rechercher..."/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Les méthodes pack et unpack en Ruby</h1>
    
    
      <p class="meta">
        <div class="sharing">
  
  <a href="//twitter.com/share" class="twitter-share-button" data-url="http://vfsvp.fr/article/les-methodes-pack-et-unpack-en-ruby" data-via="VFsvp" data-counturl="http://vfsvp.fr/article/les-methodes-pack-et-unpack-en-ruby" >Tweet</a>
  
  
  <div class="g-plusone" data-size="small"></div>
  
  
</div>

      </p>
    
    
      <p class="meta">
        








  


<time datetime="2013-10-03T12:56:00+02:00" pubdate data-updated="true">03/10/2013</time>
        
        
         | <a href="#disqus_thread">Commentaires</a>
        
      </p>
    
  </header>


<div class="entry-content"><p>C programming language allows developers to directly access the memory where variables are stored. Ruby does not allow that. There are times while working in Ruby when you need to access the underlying bits and bytes. Ruby provides two methods pack and unpack for that.</p>

<p>Here is an example.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="s1">&#39;A&#39;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;b*&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; [&quot;10000010&quot;]</span>
</span></code></pre></td></tr></table></div></figure>


<p>In the above case ‘A’ is a string which is being stored and using unpack I am trying to read the bit value. The ASCII table says that ASCII valule of ‘A’ is 65 and the binary representation of 65 is 10000010 .</p>

<p>Here is another example.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="s1">&#39;A&#39;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;B*&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; [&quot;01000001&quot;]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Notice the difference in result from the first case. What’s the difference between b<em> and B</em>. In order to understand the difference first lets discuss MSB and LSB.</p>

<h2>Most significant bit vs Least significant bit</h2>

<p>All bits are not created equal. C has ascii value of 67. The binary value of 67 is 1000011.</p>

<p>First let’s discuss MSB (most significant bit) style . If you are following MSB style then going from left to right (and you always go from left to right) then the most significant bit will come first. Because the most significant bit comes first we can pad an additional zero to the left to make the number of bits eight. After adding an additional zero to the left the binary value looks like 01000011.</p>

<p>If we want to convert this value in the LSB (Least Significant Bit) style then we need to store the least significant bit first going from left to right. Given below is how the bits will be moved if we are converting from MSB to LSB. Note that in the below case position 1 is being referred to the leftmost bit.</p>

<p>move value 1 from position 8 of MSB to position 1 of LSB
move value 1 from position 7 of MSB to position 2 of LSB
move value 0 from position 6 of MSB to position 3 of LSB
and so on and so forth</p>

<p>After the exercise is over the value will look like 11000010.</p>

<p>We did this exercise manually to understand the difference between most significant bit and least significant bit. However unpack method can directly give the result in both MSB and LSB. The unpack method can take both b<em> and B</em> as the input. As per the ruby documentation here is the differnce.</p>

<p>B | bit string (MSB first)
b | bit string (LSB first)</p>

<p>Now let’s take a look at two examples.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="s1">&#39;C&#39;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;b*&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; [&quot;11000010&quot;]</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="s1">&#39;C&#39;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;B*&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; [&quot;01000011&quot;]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Both b<em> and B</em> are looking at the same underlying data. It’s just that they represent the data differently.</p>

<h2>Different ways of getting the same data</h2>

<p>Let’s say that I want binary value for string hello . Based on the discussion in the last section that should be easy now.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="s2">&quot;hello&quot;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;B*&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; [&quot;0110100001100101011011000110110001101111&quot;]</span>
</span></code></pre></td></tr></table></div></figure>


<p>The same information can also be derived as</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="s2">&quot;hello&quot;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;C*&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span><span class="o">|</span><span class="n">e</span><span class="o">|</span> <span class="n">e</span><span class="o">.</span><span class="n">to_s</span> <span class="mi">2</span><span class="p">}</span>
</span><span class='line'><span class="c1">#=&gt; [&quot;1101000&quot;, &quot;1100101&quot;, &quot;1101100&quot;, &quot;1101100&quot;, &quot;1101111&quot;]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Let’s break down the previous statement in small steps.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="s2">&quot;hello&quot;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;C*&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; [104, 101, 108, 108, 111]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Directive C* gives the 8-bit unsigned integer value of the character. Note that ascii value of h is 104, ascii value of e is 101 and so on.</p>

<p>Using the technique discussed above I can find hex value of the string.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="s2">&quot;hello&quot;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;C*&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span><span class="o">|</span><span class="n">e</span><span class="o">|</span> <span class="n">e</span><span class="o">.</span><span class="n">to_s</span> <span class="mi">16</span><span class="p">}</span>
</span><span class='line'><span class="c1">#=&gt; [&quot;68&quot;, &quot;65&quot;, &quot;6c&quot;, &quot;6c&quot;, &quot;6f&quot;]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Hex value can also be achieved directly.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="s2">&quot;hello&quot;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;H*&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; [&quot;68656c6c6f&quot;]</span>
</span></code></pre></td></tr></table></div></figure>


<h2>High nibble first vs Low nibble first</h2>

<p>Notice the difference in the below two cases.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="s2">&quot;hello&quot;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;H*&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; [&quot;68656c6c6f&quot;]</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="s2">&quot;hello&quot;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;h*&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; [&quot;8656c6c6f6&quot;]</span>
</span></code></pre></td></tr></table></div></figure>


<p>As per ruby documentation for unpack</p>

<p>H | hex string (high nibble first)
h | hex string (low nibble first)</p>

<p>A byte consists of 8 bits. A nibble consists of 4 bits. So a byte has two nibbles. The ascii value of ‘h’ is 104. Hex value of 104 is 68. This 68 is stored in two nibbles. First nibble, meaning 4 bits, contain the value 6 and the second nibble contains the value 8. In general we deal with high nibble first and going from left to right we pick the value 6 and then 8.</p>

<p>However if you are dealing with low nibble first then low nibble value 8 will take the first slot and then 6 will come. Hence the result in “low nibble first” mode will be 86.</p>

<p>This pattern is repeated for each byte. And because of that a hex value of 68 65 6c 6c 6f looks like 86 56 c6 c6 f6 in low nibble first format.</p>

<h2>Mix and match directives</h2>

<p>In all the previous examples I used *. And a * means to keep going as long as it has to keep going. Lets see a few examples.</p>

<p>A single C will get a single byte.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="s2">&quot;hello&quot;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; [104]</span>
</span></code></pre></td></tr></table></div></figure>


<p>You can add more Cs if you like.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="s2">&quot;hello&quot;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;CC&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; [104, 101]</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="s2">&quot;hello&quot;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;CCC&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; [104, 101, 108]</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="s2">&quot;hello&quot;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;CCCCC&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; [104, 101, 108, 108, 111]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Rather than repeating all those directives, I can put a number to denote how many times you want previous directive to be repeated.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="s2">&quot;hello&quot;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;C5&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; [104, 101, 108, 108, 111]</span>
</span></code></pre></td></tr></table></div></figure>


<p>I can use * to capture al the remaining bytes.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="s2">&quot;hello&quot;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;C*&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; [104, 101, 108, 108, 111]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Below is an example where MSB and LSB are being mixed.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="s2">&quot;aa&quot;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;b8B8&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; [&quot;10000110&quot;, &quot;01100001&quot;]</span>
</span></code></pre></td></tr></table></div></figure>


<h2>pack is reverse of unpack</h2>

<p>Method pack is used to read the stored data. Let’s discuss a few examples.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'> <span class="o">[</span><span class="mi">1000001</span><span class="o">].</span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; &quot;A&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>In the above case the binary value is being interpreted as 8 bit unsigned integer and the result is ‘A’.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="o">[</span><span class="s1">&#39;A&#39;</span><span class="o">].</span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; &quot;\xA0&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>In the above case the input ‘A’ is not ASCII ‘A’ but the hex ‘A’. Why is it hex ‘A’. It is hex ‘A’ because the directive ‘H’ is telling pack to treat input value as hex value. Since ‘H’ is high nibble first and since the input has only one nibble then that means the second nibble is zero. So the input changes from [&lsquo;A&rsquo;] to [&lsquo;A0&rsquo;] .</p>

<p>Since hex value A0 does not translate into anything in the ASCII table the final output is left as it and hence the result is \xA0. The leading \x indicates that the value is hex value.</p>

<p>Notice the in hex notation A is same as a. So in the above example I can replace A with a and the result should not change. Let’s try that.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="o">[</span><span class="s1">&#39;a&#39;</span><span class="o">].</span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; &quot;\xA0&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Let’s discuss another example.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="o">[</span><span class="s1">&#39;a&#39;</span><span class="o">].</span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;h&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; &quot;\n&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>In the above example notice the change. I changed directive from H to h. Since h means low nibble first and since the input has only one nibble the value of low nibble becomes zero and the input value is treated as high nibble value. That means value changes from [&lsquo;a&rsquo;] to [&lsquo;0a&rsquo;]. And the output will be \x0A. If you look at ASCII table then hex value A is ASCII value 10 which is NL line feed, new line. Hence we see \n as the output because it represents “new line feed”.</p>

<h2>Usage of unpack in Rails source code</h2>

<p>I did a quick grep in Rails source code and found following usage of unpack.</p>

<p>email_address_obfuscated.unpack(&lsquo;C<em>&rsquo;)
&lsquo;mailto:&rsquo;.unpack(&lsquo;C</em>&rsquo;)
email_address.unpack(&lsquo;C<em>&rsquo;)
char.unpack(&lsquo;H2&rsquo;)
column.class.string_to_binary(value).unpack(&ldquo;H</em>&rdquo;)
data.unpack(&ldquo;m&rdquo;)
s.unpack(&ldquo;U*&rdquo;)</p>

<p>Already we have seen the usage of directive C<em> and H for unpack. The directive m gives the base64 encoded value and the directive U</em> gives the UTF-8 character. Here is an example.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="s2">&quot;Hello&quot;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;U*&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; [72, 101, 108, 108, 111]</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Tested with</h2>

<p>Above code was tested with ruby 1.9.2.</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Simon Courtois (simonc)</span></span>

      








  


<time datetime="2013-10-03T12:56:00+02:00" pubdate data-updated="true">03/10/2013</time>
      

<span class="categories">
  
    <a class='category' href='/tags/ruby/'>ruby</a>
  
</span>


    </p>
    <p class="meta">
      
      
    </p>
  </footer>
</article>

  <section>
    <h1>Commentaires</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>

</div>

<aside class="sidebar">
  
    <section>
  <h1>VF svp</h1>
  <p>VF svp est un projet communautaire de traduction d'articles techniques.
    Pour proposer une traduction, rendez-vous sur
    <a href="http://github.com/simonc/vfsvp.fr" title="Page Github du projet VF svp">le Github du projet</a>.</p>
</section>

  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - Simon Courtois (simonc) -
  <span class="credit">Publié grâce à <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  
<script type="text/javascript">
    var disqus_shortname = 'vfsvp-fr';
    
      var disqus_identifier = 'http://vfsvp.fr/article/les-methodes-pack-et-unpack-en-ruby';
      var disqus_url = 'http://vfsvp.fr/article/les-methodes-pack-et-unpack-en-ruby';
      var disqus_script = 'embed.js';
    
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>





  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





  <script src="/javascripts/modernizr-2.0.js"></script>
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
<script src="/javascripts/octopress.js" type="text/javascript"></script>

  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-15419839-2']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>



</body>
</html>
