<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[VF svp]]></title>
  <link href="http://vfsvp.fr/atom.xml" rel="self"/>
  <link href="http://vfsvp.fr/"/>
  <updated>2013-11-01T13:38:28+01:00</updated>
  <id>http://vfsvp.fr/</id>
  <author>
    <name><![CDATA[Simon Courtois (simonc)]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Elixir pour les rubyists (partie 2)]]></title>
    <link href="http://vfsvp.fr/article/elixir-pour-les-rubyists-2"/>
    <updated>2013-10-29T21:00:00+01:00</updated>
    <id>http://vfsvp.fr/article/elixir-pour-les-rubyists-2</id>
    <content type="html"><![CDATA[<p>Source: <a href="http://www.natescottwest.com/blog/2013/10/09/elixir-for-rubyists-part-2/">Elixir for Rubyists part 2 par Nate West</a></p>

<p>Voici une tentative de réponse aux questions de la <a href="http://vfsvp.fr/article/elixir-pour-les-rubyists-1">partie 1</a>.</p>

<h2>Immuable ??</h2>

<p>Les variables d&#8217;Elixir sont immuables. Elles ne sont pas à assignation unique.
Je vous entends déjà dire &ldquo;Mais Nate ! Si on réassigne une variable, n&#8217;est-ce
pas une mutation ?&rdquo;. Non !</p>

<h2>Elixir assure la transparence référentielle des variables</h2>

<p>Transparence référentielle est une façon académique de dire &ldquo;quand je fais
quelque chose qui modifie une valeur, je peux toujours revenir à la valeur
originale&rdquo;. Jessica Kerr (<a href="https://twitter.com/jessitron">@jessitron</a>) appelle
cela &ldquo;données en entrée, données en sortie&rdquo; (<em>data in, data out</em>). Sous forme
de code :</p>

<!-- more -->




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='elixir'><span class='line'><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Nate&quot;</span>
</span><span class='line'><span class="c1"># =&gt; &quot;Nate&quot;</span>
</span><span class='line'><span class="no">String</span><span class="o">.</span><span class="n">upcase</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
</span><span class='line'><span class="c1"># =&gt; &quot;NATE&quot;</span>
</span><span class='line'><span class="n">name</span>
</span><span class='line'><span class="c1"># =&gt; &quot;Nate&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>String.upcase</code> est référentiellement transparent. Il retourne une nouvelle
valeur transformée mais ne modifie pas la valeur originale. On peut comparer
cela avec <code>String#upcase!</code> en Ruby.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">name</span> <span class="o">=</span> <span class="s2">&quot;Nate&quot;</span>
</span><span class='line'><span class="c1"># =&gt; &quot;Nate&quot;</span>
</span><span class='line'><span class="nb">name</span><span class="o">.</span><span class="n">upcase!</span>
</span><span class='line'><span class="c1"># =&gt; &quot;NATE&quot;</span>
</span><span class='line'><span class="nb">name</span>
</span><span class='line'><span class="c1"># =&gt; &quot;NATE&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>String#upcase!</code> <em>n&#8217;est pas</em> référentiellement transparent. Non seulement il
retourne une valeur transformée mais modifie également la valeur originale.</p>

<p>Avec Elixir, dans le contexte d&#8217;une fonction vous ne pourrez pas modifier la
valeur d&#8217;une variable.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='elixir'><span class='line'><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Nate&quot;</span>
</span><span class='line'><span class="c1"># =&gt; &quot;Nate&quot;</span>
</span><span class='line'><span class="n">capitalize</span> <span class="o">=</span> <span class="k">fn</span><span class="p">(</span><span class="n">string</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">string</span> <span class="o">=</span> <span class="no">String</span><span class="o">.</span><span class="n">upcase</span><span class="p">(</span><span class="n">string</span><span class="p">)</span> <span class="k">end</span>
</span><span class='line'><span class="c1"># =&gt; #Function&lt;6.80484245 in :erl_eval.expr/5&gt;</span>
</span><span class='line'><span class="n">capitalize</span><span class="o">.</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
</span><span class='line'><span class="c1"># =&gt; &quot;NATE&quot;</span>
</span><span class='line'><span class="n">name</span>
</span><span class='line'><span class="c1"># =&gt; &quot;Nate&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<h2>En quoi la transparence référentielle est importante ?</h2>

<p>Pour faire court, un code référentiellement transparent est simple à tester,
facile à comprendre et à rendre <em>threadsafe</em>. Si on a ceci en Ruby :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='elixir'><span class='line'><span class="n">greeting</span> <span class="o">=</span> <span class="s2">&quot;Hello&quot;</span>
</span><span class='line'><span class="n">do_something_to_string</span><span class="p">(</span><span class="n">greeting</span><span class="p">)</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">greeting</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>On s&#8217;attend à ce que <code>greeting</code> ait la valeur &ldquo;Hello&rdquo; lorsque l&#8217;on appelle
<code>print</code> mais <code>do_something_to_string</code> a pu modifier la valeur de <code>greeting</code>.
D&#8217;autant plus si <code>greeting</code> est transmis un peu partout dans l&#8217;application et
passe par toutes sortes de <code>do_somethings</code>. Au moment d&#8217;afficher <code>greeting</code>, il
pourrait tout aussi bien contenir &ldquo;Game over !&rdquo;.</p>

<p>Pour en savoir plus :</p>

<ul>
<li><a href="http://confreaks.com/videos/2382-rmw2013-functional-principles-for-oo-development">Jessica Kerr’s Functional Principles (en)</a></li>
<li><a href="http://rubyrogues.com/115-rr-functional-and-object-oriented-programming-with-jessica-kerr/">Ruby Rogues Podcast: Functional and OO Programming (en)</a></li>
<li>Si vous pensez à d&#8217;autres ressources, dites le moi, je les ajouterai.</li>
</ul>


<h2>Un piège&hellip;</h2>

<p>Il est possible d&#8217;assigner une nouvelle valeur à une variable en se basant sur
sa valeur actuelle. Notez bien qu&#8217;ici <code>=</code> n&#8217;est pas un opérateur d&#8217;assignation.
C&#8217;est un opérateur de test de correspondance. Lorsque l&#8217;on utilise sur une
variable, on peut choisir de tester la valeur de la variable ou nous pouvons
l&#8217;autoriser à prendre une nouvelle valeur.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='elixir'><span class='line'><span class="m">1</span> <span class="o">=</span> <span class="m">2</span> <span class="c1"># la valeur 1 ne correspond pas à la valeur 2</span>
</span><span class='line'><span class="c1"># =&gt; ** (MatchError) aucune correspondance avec : 3</span>
</span><span class='line'><span class="c1">#    :erl_eval.expr/3</span>
</span><span class='line'>
</span><span class='line'><span class="ss">:a</span> <span class="o">=</span> <span class="m">2</span> <span class="c1"># la valeur :a, un atôme (un peu comme un symbole en Ruby),</span>
</span><span class='line'>       <span class="c1"># ne correspond pas à la valeur 2</span>
</span><span class='line'><span class="c1"># =&gt; ** (MatchError) aucune correspondance avec : 3</span>
</span><span class='line'><span class="c1">#    :erl_eval.expr/3</span>
</span><span class='line'>
</span><span class='line'><span class="n">num</span> <span class="o">=</span> <span class="m">2</span> <span class="c1"># num est une variable. Nous pouvons lui assigner 2 pour établir</span>
</span><span class='line'>        <span class="c1"># une correspondance.</span>
</span><span class='line'><span class="c1"># =&gt; 2</span>
</span><span class='line'>
</span><span class='line'><span class="o">^</span><span class="n">num</span> <span class="o">=</span> <span class="m">3</span> <span class="c1"># la valeur de num (2) ne correspond pas à la valeur 3</span>
</span><span class='line'><span class="c1"># =&gt; ** (MatchError) aucune correspondance avec : 3</span>
</span><span class='line'><span class="c1">#    :erl_eval.expr/3</span>
</span><span class='line'>
</span><span class='line'><span class="n">num</span> <span class="o">=</span> <span class="m">3</span> <span class="c1"># ici on ne cherche pas de correspondance, on peut donc assigner la</span>
</span><span class='line'>        <span class="c1"># valeur 3 à num</span>
</span><span class='line'><span class="c1"># =&gt; 3</span>
</span></code></pre></td></tr></table></div></figure>


<p>Tel que je le comprends, cela fait parti d&#8217;Elixir pour des questions pratique
et est particulièrement utile pour écrire des macros. Les puristes de la
programmation fonctionnelle vont détester ça. Si c&#8217;est votre cas, vous pouvez
lire <a href="https://groups.google.com/forum/#!searchin/elixir-lang-core/single$20assignment/elixir-lang-core/FrK7MQGuqWc/2aimbHDAAHMJ">cette discussion</a>
au sujet de la réassignation de variables dans Elixir et jeter un oeil au
commentaire de Joe Armstrong.</p>

<p>Encore une fois, cela ne change pas l&#8217;état de l&#8217;objet. Il n&#8217;y a pas d&#8217;objet dans
Elixir. <code>num</code> est un simple conteneur de données auquel vous pouvez donner une
nouvelle valeur. Lorsque vous le faites, l&#8217;ancienne valeur va être retirée du
contexte d&#8217;exécution afin de laisser la place libre pour stocker une nouvelle
valeur.</p>

<h2>Essayez donc de le briser</h2>

<p>Vous aurez tout de même beaucoup de mal à écrire une fonction qui brise la
transparence référentielle. Si vous réassignez une variable dans une fonction,
vous ne changez sa valeur que pour le contexte de cette fonction.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='elixir'><span class='line'><span class="k">defmodule</span> <span class="no">Assignment</span> <span class="k">do</span>
</span><span class='line'><span class="k">  def</span> <span class="n">change_me</span><span class="p">(</span><span class="n">string</span><span class="p">)</span> <span class="k">do</span>
</span><span class='line'><span class="k">    </span><span class="n">string</span> <span class="o">=</span> <span class="m">2</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># lorsque vous compilez ce module, vous aurez un warning indiquant</span>
</span><span class='line'><span class="c1"># qu&#39;une variable de type string n&#39;est pas utilisée!</span>
</span><span class='line'>
</span><span class='line'><span class="n">greeting</span> <span class="o">=</span> <span class="s2">&quot;Hi&quot;</span>
</span><span class='line'><span class="c1"># =&gt; &quot;Hi&quot;</span>
</span><span class='line'><span class="no">Assignment</span><span class="o">.</span><span class="n">change_me</span><span class="p">(</span><span class="n">greeting</span><span class="p">)</span>
</span><span class='line'><span class="c1"># =&gt; 2</span>
</span><span class='line'><span class="n">greeting</span>
</span><span class='line'><span class="c1"># =&gt; &quot;Hi&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<h2>C&#8217;est tout pour aujourd&#8217;hui</h2>

<p>Voici la fin de la partie 2. À bientôt pour la partie 3.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git est une structure de données purement fonctionnelle]]></title>
    <link href="http://vfsvp.fr/article/Git-est-une-structure-de-donnees-purement-fonctionnelle"/>
    <updated>2013-10-28T23:00:00+01:00</updated>
    <id>http://vfsvp.fr/article/Git-est-une-structure-de-donnees-purement-fonctionnelle</id>
    <content type="html"><![CDATA[<p>Source: <a href="http://www.jayway.com/2013/03/03/git-is-a-purely-functional-data-structure/">Git is a purely functional data structure de Philip Nilsson sur le blog de Jayway</a></p>

<p>Bien que les systèmes de gestion de versions décentralisés, comme Git, aient le
vent en poupe en ce moment, ils semblent toujours avoir la réputation d&#8217;être
plus complexes que leurs homologues centralisés, comme SVN. Je pense que l&#8217;une
des raisons est que l&#8217;on a tendance à expliquer Git par comparaison : lorsque tu
fait X avec SVN, tu fais Y avec Git.</p>

<p>Selon moi nous devrions plutôt présenter Git comme ce qu&#8217;il est : une structure
de données purement fonctionnelle. Devenir expert Git implique d&#8217;apprendre à
maitriser cette structure de données.</p>

<p>Si la notion de structure de données purement fonctionnelle vous est étrangère,
cela ne va pas vous être d&#8217;une grande aide. Il se trouve qu&#8217;un minimum de
connaissances sur le sujet suffit pour comprendre, nous allons donc passer
rapidement sur ce sujet avant de revenir à Git.</p>

<!-- more -->


<h2>Notions préliminaires</h2>

<p>Une structure de données fonctionnelle est essentiellement une structure de
données immuable : ses valeurs ne changent jamais. Cependant, contrairement à la
<code>ReadOnlyCollection</code> de C# qui n&#8217;a pas d&#8217;opérations (insertion par exemple), les
structures de données fonctionnelles supportent les opération comme l&#8217;insertion
ou la suppression. Ces opérations sont effectuées en créant une nouvelle
structure mise à jour.</p>

<p>Par exemple, une liste classique ressemble à <code>[3,2,1]</code>. Si cette liste est
modifiable et que nous voulons insérer la valeur <code>4</code> en tête (<em>head</em>) de liste,
cette dernière ressemble maintenant à <code>[4,3,2,1]</code>. Elle a été directement
modifiée et l&#8217;ancienne valeur, <code>[3,2,1]</code> est perdue. Si quelqu&#8217;un d&#8217;autre
utilisait cette liste, il voit maintenant <code>[4,3,2,1]</code>. Si cette personne était
en pleine itération sur la liste, elle a maintenant une jolie exception.</p>

<p>Dans le modèle fonctionnel, ce genre de cas n&#8217;arrive pas. Lorsque l&#8217;on insert
<code>4</code> dans la liste, une nouvelle valeur <code>[4,3,2,1]</code> est créée, sans modifier la
liste originale. Les deux valeurs <code>[4,3,2,1]</code> et <code>[3,2,1]</code> existent et si
quelqu&#8217;un utilisait l&#8217;ancienne liste <code>[3,2,1]</code>, il a toujours accès à celle-ci.</p>

<p>Vous vous dites peut être que c&#8217;est une façon inefficace de fonctionner. Si nous
avons accès aux deux listes <code>[4,3,2,1]</code> et <code>[3,2,1]</code>, nous devons stocker ces
sept éléments en mémoire, non ? Même si nous n&#8217;avons pas besoin d&#8217;accéder à la
valeur <code>[3,2,1]</code>. En réalité, l&#8217;efficacité des structures de données
fonctionnelles dépend des opérations effectuées dessus et de comment leur
représentation interne est utilisée (tout comme les structures classiques mais
avec d&#8217;autres avantages, coûts et compromis).</p>

<p>Pour une liste (simplement chaînée), si tout ce que nous voulons est insérer de
nouveaux éléments en tête, nous pouvons de faire efficacement en stockant les
éléments comme ceci :</p>

<pre><code>  +---+    +---+    +---+    +---+
  | 4 +---&gt;+ 3 +---&gt;+ 2 +---&gt;+ 1 |
  +---+    +---+    +---+    +---+
    |        |
new list  original
</code></pre>

<p>Nous ajoutons <code>4</code> dans une nouvelle cellule contenant un lien vers le reste de
la liste. Cette valeur original est représentée par la référence existante,
en commençant à la cellule de valeur <code>3</code>. Si quelqu&#8217;un d&#8217;autre a une référence
sur cette cellule, il ne verra jamais que la liste a été mise à jour (ce qui ne
serait pas le cas pour une liste doublement chaînée). Nous pouvons donc affirmer
avoir un accès indépendant aux deux listes, <code>[4,2,3,1]</code> et <code>[3,2,1]</code>, quand bien
même elles partagent des éléments en mémoire. Sans opération de modification
directe, aucune différence n&#8217;est perceptible.</p>

<p>Nous pourrions aller encore plus loin : Si quelqu&#8217;un souhaite insérer la valeur
<code>9</code> en tête de la liste <code>[3,2,1]</code>, il peut le faire indépendamment de notre
utilisation de celle-ci, en utilisant les mêmes éléments.</p>

<pre><code>              +---+      +---+    +---+    +---+
new list 1 -&gt; | 4 +---+-&gt;+ 3 +---&gt;+ 2 +---&gt;+ 1 |
              +---+  /   +---+    +---+    +---+
                    /      |
              +---+/    original
new list 2 -&gt; | 9 +
              +---+
</code></pre>

<p>Nous pourrions bien sûr stocker de cette façon une liste modifiable mais cela
pourrait être dangereux. Si, par exemple, nous mettions à jour la cellule <code>3</code>
dans la liste <code>[4,3,2,1]</code>, elle serait également mise à jour dans la liste
<code>[9,3,2,1]</code> ce qui pourrait ne pas être apprécié.</p>

<p>Mais… comment faire si je souhaite vraiment changer <code>3</code> en lui donnant la valeur
<code>5</code>, par exemple ? Comme nous ne pouvons pas effectuer de modification directe,
nous devons copier quelques cellules dans la liste mise à jour. Le résultat de
l&#8217;opération ressemble donc à ceci :</p>

<pre><code>                +---+    +---+
updated list -&gt; | 4 +---&gt;+ 5 +----+
                +---+    +---+     \
                                    \
                +---+    +---+    +-+-+    +---+
  new list 1 -&gt; | 4 +---&gt;+ 3 +---&gt;+ 2 +---&gt;+ 1 |
                +---+  / +---+    +---+    +---+
                      /    |
                +---+/  original
  new list 2 -&gt; | 9 +
                +---+
</code></pre>

<p>En allant vers l&#8217;arrière à partir de chaque pointeur, nous pouvons voir que ceci
représente à la fois les listes <code>[4,5,2,1]</code>, <code>[4,3,2,1]</code>, <code>[9,3,2,1]</code> et
<code>[3,2,1]</code>. Si nous voulons stocker toutes ces valeurs en même temps, cette
représentation est bien plus efficace que plusieurs listes modifiables.</p>

<p>Les structures de données purement fonctionnelles sont très utiles en
programmation multi-thread puisque une modification effectuée dans un thread
n&#8217;impactera pas les autres.</p>

<h2>Comprendre Git</h2>

<p>Voyons maintenant quel est le rapport entre tout ceci et Git. Avec un système de
gestion de versions, ce que l&#8217;on cherche à accomplir c&#8217;est :</p>

<ul>
<li>mettre à jour notre code avec de nouvelles versions tout en gardant les
anciennes disponibles ;</li>
<li>Travailler à plusieurs sur un même code sans que les mises à jour
n&#8217;interfèrent entre elles de façon imprévisible.</li>
</ul>


<p>Une structure de données fonctionnelle permet de</p>

<ul>
<li>Mettre à jour la structure tout en gardant un accès aux anciennes valeurs ;</li>
<li>Mettre à jour la structure à un endroit sans interférer avec quelqu&#8217;un d&#8217;autre
mettant également la structure à jour.</li>
</ul>


<p>Si vous vous dites que les structures de données fonctionnelles sont une bonne
représentation pour un système de gestion de versions, vous êtes dans le vrai.
J&#8217;irais même plus loin en disant que Git simplement une structure de données
purement fonctionnelle avec un client en ligne de commande permettant
d&#8217;effectuer des opérations dessus.</p>

<p>Pour compléter l&#8217;analogie, nous devons remplacer ce qui était précédemment une
suite de chiffres par des commits. Les commits Git sont des copies indépendantes
de l&#8217;état complet du code à un point donné dans le temps. Ce que jusque là nous
appelions liste est ce que l&#8217;on appelle historique en Git.</p>

<p>Soit un dépôt contenant, dans la branche <code>master</code> et dans l&#8217;ordre, les commits
A, B et C. Nous avons demandé trois fois à Git de stocker l&#8217;intégralité de
l&#8217;état de notre code.</p>

<p>Nous pouvons représenter cela sous la forme <code>[C,B,A]</code>. En réalité, chaque commit
a des meta-données, comme un message de commit, mais allons ignorer ce fait pour
une question de simplicité. Voici la version graphe :</p>

<pre><code>+---+    +---+    +---+
+ C +---&gt;+ B +---&gt;+ A |
+---+    +---+    +---+
  |
master
</code></pre>

<h2>Faire un commit</h2>

<p>Si nous créons un nouveau commit, cela revient à ajouter en tête de
l&#8217;historique. Git utilise même le nom <code>HEAD</code> pour référencer le commit actif.</p>

<pre><code>+---+    +---+    +---+    +---+
+ D +---&gt;+ C +---&gt;+ B +---&gt;+ A |
+---+    +---+    +---+    +---+
  |        |
master   master^
</code></pre>

<p>Lorsque Git créer un commit, il déplace le pointeur de la branche courante pour
nous et fait pointer <code>master</code> sur l&#8217;historique <code>[D,C,B,A]</code>. Nous pouvons
toujours faire référence à <code>[C,B,A]</code> en utilisant <code>master^</code>, le parent de
<code>master</code>. Si quelqu&#8217;un travaille avec cette historique, il ne verra pas nos
modifications.</p>

<h2>Corriger un commit</h2>

<p>Si vous avez déjà utilisé Git, vous savez probablement que l&#8217;on peut modifier
son dernier commit grâce à <code>commit --amend</code>. Mais pouvez-vous réellement
modifier un commit ? En réalité, non. Git crée simplement un nouveau commit et
fait pointer votre branche dessus. L&#8217;ancien commit peut être retrouvé grâce à
<code>git reflog</code> et vous pouvez y faire référence via son <em>hash</em> (j&#8217;ai ici utilisé
la valeur arbitraire <code>ef4d34</code>). L&#8217;état du dépôt est donc le suivant :</p>

<pre><code>          +---+    +---+    +---+    +---+
ef4d34 -&gt; | D +--+&gt;+ C +---&gt;+ B +---&gt;+ A |
          +---+ /  +---+    +---+    +---+
               /     |
          +---+    master^
master -&gt; | E |
          +---+
</code></pre>

<h2>Les branches</h2>

<p>Comme vous avez pu le voir juste avant, lorsque vous utilisez <code>commit --amend</code>,
vous créez en fait une nouvelle branche (il y a une fourche dans le graphe). La
seule différence lors de la création d&#8217;une branche est qu&#8217;un nouveau nom est
créé pour se référer aux commits. Nous pouvons même créer une branche à partir
du commit <code>ef4d34</code> grâce à la commande <code>git checkout -b branch ef4d34</code>.</p>

<pre><code>          +---+    +---+    +---+    +---+
branch -&gt; | D +--+&gt;+ C +---&gt;+ B +---&gt;+ A |
          +---+ /  +---+    +---+    +---+
               /     |
          +---+  master^
master -&gt; | E |
          +---+
</code></pre>

<p>En général, lorsque l&#8217;on crée une branche dans Git, celle-ci pointe sur le
<code>HEAD</code> courant mais dés lors que l&#8217;on voit Git comme une structure de données
fonctionnelle, rien n&#8217;empêche de créer une branche à partir de n&#8217;importe quel
commit existant.</p>

<h2>Utiliser rebase</h2>

<p>Dans les exemples sur les structures de données, lorsque nous modifions une
cellule à un certain point de l&#8217;historique, nous devions copier toutes les
cellules se trouvant à la suite de celle modifiée (la cellule <code>4</code> dans notre
exemple mais il aurait pu y en avoir plus). Dans Git, c&#8217;est ce que l&#8217;on appelle
rejouer les commits et la commande permettant de le faire est nommée <code>rebase</code>.
Pour mettre à jour un ancien commit, nous ajoutons l&#8217;option <code>-i</code> pour passer en
mode <em>interactif</em>.</p>

<p>Si nous souhaitons modifier le commit <code>C</code> et changer son message, nous faisons
un checkout sur le commit <code>B</code>
Say we want to update the commit C with a new commit message. We do
this by checking out the commit D, and using git rebase -i C.</p>

<p>NOTE: Erreur dans le texte original B/D</p>

<pre><code>git checkout B
git rebase -i C
</code></pre>

<p>Cette commande ouvre le même éditeur que celui utilisé par Git pour les messages
de commit avec un contenu similaire à cette liste de commandes :</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pick cd3ff32 &lt;message de commit de C&gt;
</span><span class='line'>pick a65a671 &lt;message de commit de D&gt;
</span><span class='line'>
</span><span class='line'># some helpful comments from git</span></code></pre></td></tr></table></div></figure>


<p>Si nous changeons la commande du commit <code>C</code> pour <code>edit</code>, Git nous permet de
modifier ce commit avant de rejouer les commits suivants.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>edit cd3ff32 &lt;message de commit de C&gt;
</span><span class='line'>pick a65a671 &lt;message de commit de D&gt;</span></code></pre></td></tr></table></div></figure>


<p>Lorsque nous sauvegardons le fichier et fermons l&#8217;éditeur, Git commence une
opération de <em>rebase</em>. Il s&#8217;arrête pour nous permettre de modifier le commit
<code>C</code>.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Stoppé à cd3ff32... &lt;message de commit de C&gt;
</span><span class='line'>Vous pouvez modifier votre commit avec
</span><span class='line'>
</span><span class='line'>        git commit --amend
</span><span class='line'>
</span><span class='line'>Une fois satisfait de vos changements, lancez
</span><span class='line'>
</span><span class='line'>        git rebase --continue</span></code></pre></td></tr></table></div></figure>


<p>Le message est assez clair, nous pouvons modifier le commit comme bon nous
semble. Une fois cela fait nous appelons <code>commit --amend</code> pour créer le commit
mis à jour puis reprenons la liste des commandes de <em>rebase</em> grâce à <code>rebase
--continue</code>. Les autres commits seront rejoués l&#8217;un après l&#8217;autre puisque nous
avons choisi la commande <code>pick</code>. En cas de conflit, Git s&#8217;arrête et vous laisse
corriger avant de continuer. Notre dépôt ressemble maintenant à ceci :</p>

<pre><code>          +---+    +---+
rebased -&gt;| D'+---&gt;+ C'+
          +---+    +---+\
                         \
          +---+    +---+  \ +---+    +---+
branch -&gt; | D +--+&gt;+ C +---&gt;+ B +---&gt;+ A |
          +---+ /  +---+    +---+    +---+
               /     |
          +---+  master^
master -&gt; | E |
          +---+
</code></pre>

<p>Ce graphe ne doit pas vous être inconnu. J&#8217;espère que vous comprenez maintenant
pourquoi la commande <code>rebase</code> crée de nouveaux commits. Git est une structure de
données fonctionnelle et ne peut donc pas modifier un commit existant.</p>

<p>Puisque <code>rebase</code> crée une nouvelle chaîne de commits, il semble normal de
pouvoir modifier ce que cette dernière contient et c&#8217;est le cas : <code>rebase -i</code>
nous permet de réordoner, fusionner ou supprimer des commits. Nous pouvons
également en créer de nouveaux à tout moment (pour couper un commit en deux par
exemple) ou commencer à un autre point de l&#8217;historique grâce à l&#8217;option
<code>--onto</code>. Le processus classique de reporter des changements locaux &ldquo;au dessus&rdquo;
de mise à jour d&#8217;une branche distante est simplement un cas d&#8217;application plus
spécifique de la puissance de <code>rebase</code>.</p>

<h2>Fusionner</h2>

<p>Nous n&#8217;avons pas parler de la fusion de commits (merging). Git nous permet de
fusionner deux branches en une.</p>

<pre><code>        +---+
      --+ X |
+---+/  +---+
| M |
+---+\  +---+
      --+ Y |
        +---+
</code></pre>

<p>Fusionner ajoute un peu de complexité à notre modèle. Notre historique n&#8217;est
plus vraiment un arbre, c&#8217;est un graphe acyclique. En réalité, cela ne change
pas grand chose mais il est amusant de noter que <code>rebase</code>, qui a la réputation
d&#8217;être plus complexe, introduit moins de complications conceptuelles que
<code>merge</code>.</p>

<p>Rebase peut se voir comme l&#8217;application de nouveaux commits dans une nouvelle
direction. Merge est une opération fondamentalement différente. Une structure de
données dans laquelle il est possible de combiner deux cellules en une a un
nom : c&#8217;est ce qu&#8217;on appelle une structure de données persistante confluante.
Une autre appellation des structures de données fonctionnelles est
structures de données persistantes. J&#8217;ai préféré éviter ce terme pour ne pas
entrainer de confusion avec la notion de stockage sur media persistants comme
un disque dur par exemple.</p>

<h2>Conclusion</h2>

<p>Git peut être assez justement perçu comme une simple structure de données
fonctionnelle. Plutôt que de présenter Git comme un outil gestion de versions, nous pouvons voir la gestion de versions comme une résultante de l&#8217;utilisation
de cette structure de données. Je pense qu&#8217;expliquer Git de cette façon exprime
mieux la simplicité et la puissance de Git que de comparer son fonctionnement
avec celui des systèmes centralisés.</p>

<p>Lorsque l&#8217;on voit cela sous cet angle, je trouve que finalement Git est bien
plus simple que SVN par exemple. La seule raison pour laquelle Git peut être
perçu comme plus complexe est que cette simplicité nous permet d&#8217;implémenter des
workflows plus intéressants.</p>

<p>Si vous avez toujours trouvé Git intimidant, gardez en mémoire sa structure
simple et le fait que dans toute structure de données fonctionnelle, rien n&#8217;est
jamais réellement perdu et peut être retrouvé (regardez <code>reflog</code>).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elixir pour les rubyists (partie 1)]]></title>
    <link href="http://vfsvp.fr/article/elixir-pour-les-rubyists-1"/>
    <updated>2013-10-27T18:30:00+01:00</updated>
    <id>http://vfsvp.fr/article/elixir-pour-les-rubyists-1</id>
    <content type="html"><![CDATA[<p>Source: <a href="http://www.natescottwest.com/blog/2013/09/26/elixir-for-rubyists/">Elixir for Rubyists part 1 par Nate West</a></p>

<p>Elixir est mon nouveau langage préféré. Cet article est le premier d&#8217;une série
de longueur indéterminée sur Elixir. En tant que rubyist, la syntaxe d&#8217;Elixir va
vous sembler familière. Je vais donc vous montrer beaucoup de code pour
vous expliquer comment il marche. Elixir est fonctionnel et amusant
(FUNctional).</p>

<p>Elixir est un langage fonctionnel qui tourne sur la VM Erlang mais ressemble
beaucoup à Ruby.</p>

<!-- more -->




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='elixir'><span class='line'><span class="m">2</span> <span class="o">+</span> <span class="m">2</span>
</span><span class='line'><span class="c1"># =&gt; 4</span>
</span><span class='line'>
</span><span class='line'><span class="no">IO</span><span class="o">.</span><span class="n">puts</span> <span class="s2">&quot;Hello!&quot;</span>
</span><span class='line'><span class="c1"># =&gt; Hello!</span>
</span><span class='line'><span class="c1">#    :ok</span>
</span><span class='line'>
</span><span class='line'><span class="no">String</span><span class="o">.</span><span class="n">downcase</span><span class="p">(</span><span class="s2">&quot;JE NE CRIE PAS&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1"># =&gt; &quot;je ne crie pas&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="k">defmodule</span> <span class="no">Numbers</span> <span class="k">do</span>
</span><span class='line'><span class="k">  def</span> <span class="n">add_to</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="k">do</span>
</span><span class='line'><span class="k">    if</span> <span class="n">is_number</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="k">do</span>
</span><span class='line'><span class="k">      </span><span class="n">num</span> <span class="o">+</span> <span class="m">2</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'>      <span class="k">raise</span><span class="p">(</span><span class="no">ArgumenError</span><span class="p">,</span> <span class="ss">message:</span> <span class="s2">&quot;L&#39;argument doit etre un nombre&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="no">Numbers</span><span class="o">.</span><span class="n">add_to</span><span class="p">(</span><span class="m">4</span><span class="p">)</span>
</span><span class='line'><span class="c1"># =&gt; 6</span>
</span><span class='line'><span class="no">Numbers</span><span class="o">.</span><span class="n">add_to</span><span class="p">(</span><span class="s2">&quot;Nate&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1"># =&gt; ** (ArgumenError) L&#39;argument doit etre un nombre</span>
</span></code></pre></td></tr></table></div></figure>


<p>Elixir utilise la détection par motif (<em>pattern matching</em>) pour effectuer des
comparaisons et assigner des valeurs aux variables.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='elixir'><span class='line'><span class="n">a</span> <span class="o">=</span> <span class="m">2</span>
</span><span class='line'><span class="c1"># =&gt; 2</span>
</span><span class='line'>
</span><span class='line'><span class="m">2</span> <span class="o">=</span> <span class="n">a</span>
</span><span class='line'><span class="c1"># =&gt; 2</span>
</span><span class='line'>
</span><span class='line'><span class="p">{</span> <span class="n">success</span><span class="p">,</span> <span class="n">string</span> <span class="p">}</span> <span class="o">=</span> <span class="p">{</span> <span class="ss">:ok</span><span class="p">,</span> <span class="s2">&quot;Hey Joe, tu sais quoi ?&quot;</span> <span class="p">}</span>
</span><span class='line'><span class="c1"># =&gt; {:ok, &quot;Hey Joe, tu sais quoi ?&quot;}</span>
</span><span class='line'><span class="n">success</span>
</span><span class='line'><span class="c1"># =&gt; :ok</span>
</span><span class='line'><span class="n">string</span>
</span><span class='line'><span class="c1"># =&gt; &quot;Hey Joe, tu sais quoi ?&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Elixir est fonctionnel, les variables sont donc immuables. Cependant,
contrairement à Erlang, ces dernières ne sont pas limitées à une seule
assignation. Si vous voulez détecter le motif de la valeur d&#8217;une variable, vous
devez utiliser un circonflexe <code>^</code>. Sans le circonflexe vous pouvez assigner une
nouvelle valeur à la variable.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='elixir'><span class='line'><span class="n">a</span> <span class="o">=</span> <span class="m">2</span>
</span><span class='line'><span class="c1"># =&gt; 2</span>
</span><span class='line'><span class="o">^</span><span class="n">a</span> <span class="o">=</span> <span class="m">3</span>
</span><span class='line'><span class="c1"># =&gt; ** (MatchError) aucune correspondance avec : 3</span>
</span><span class='line'><span class="c1">#    :erl_eval.expr/3</span>
</span><span class='line'><span class="n">a</span> <span class="o">=</span> <span class="m">3</span>
</span><span class='line'><span class="c1"># =&gt; 3</span>
</span></code></pre></td></tr></table></div></figure>


<p>Comme tout langage fonctionnel, Elixir traite les fonctions comme des citoyens
de premier ordre. Vous pouvez assigner une fonction à une variable pour une
évaluation différée. Notez l&#8217;interpolation de chaîne dans l&#8217;exemple suivant,
une autre ressemblance à Ruby.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='elixir'><span class='line'><span class="n">greeter</span> <span class="o">=</span> <span class="k">fn</span> <span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="no">IO</span><span class="o">.</span><span class="n">puts</span> <span class="s2">&quot;Hello </span><span class="si">#{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">end</span>
</span><span class='line'><span class="c1"># =&gt; #Function&lt;6.80484245 in :erl_eval.expr/5&gt;</span>
</span><span class='line'><span class="n">greeter</span><span class="o">.</span><span class="p">(</span><span class="s2">&quot;Nate&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1"># =&gt; Hello Nate</span>
</span><span class='line'><span class="c1">#    :ok</span>
</span></code></pre></td></tr></table></div></figure>


<p>Vous pouvez écrire des fonctions qui retournent des fonctions.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='elixir'><span class='line'><span class="k">defmodule</span> <span class="no">FunctionExamples</span> <span class="k">do</span>
</span><span class='line'><span class="k">  def</span> <span class="n">build_greeter</span><span class="p">(</span><span class="n">kind</span><span class="p">)</span> <span class="k">do</span>
</span><span class='line'><span class="k">    case</span> <span class="n">kind</span> <span class="k">do</span>
</span><span class='line'><span class="k">      </span><span class="ss">:hello</span> <span class="o">-&gt;</span> <span class="k">fn</span> <span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Coucou, </span><span class="si">#{</span><span class="n">name</span><span class="si">}</span><span class="s2">!&quot;</span> <span class="k">end</span>
</span><span class='line'>      <span class="ss">:goodbye</span> <span class="o">-&gt;</span> <span class="k">fn</span> <span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;A plus, </span><span class="si">#{</span><span class="n">name</span><span class="si">}</span><span class="s2">!&quot;</span> <span class="k">end</span>
</span><span class='line'>      <span class="n">_</span> <span class="o">-&gt;</span> <span class="k">fn</span> <span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Je ne sais pas quoi te dire, </span><span class="si">#{</span><span class="n">name</span><span class="si">}</span><span class="s2">.&quot;</span> <span class="k">end</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">say_hello</span> <span class="o">=</span> <span class="no">FunctionExamples</span><span class="o">.</span><span class="n">build_greeter</span><span class="p">(</span><span class="ss">:hello</span><span class="p">)</span>
</span><span class='line'><span class="c1"># =&gt; #Function&lt;0.63189797 in FunctionExamples.build_greeter/1&gt;</span>
</span><span class='line'><span class="n">say_hello</span><span class="o">.</span><span class="p">(</span><span class="s2">&quot;Nate&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1"># =&gt; Coucou, Nate!</span>
</span><span class='line'><span class="c1">#    :ok</span>
</span><span class='line'>
</span><span class='line'><span class="n">wat</span> <span class="o">=</span> <span class="no">FunctionExamples</span><span class="o">.</span><span class="n">build_greeter</span><span class="p">(</span><span class="ss">:something_else</span><span class="p">)</span>
</span><span class='line'><span class="c1"># =&gt; #Function&lt;2.63189797 in FunctionExamples.build_greeter/1&gt;</span>
</span><span class='line'><span class="n">wat</span><span class="o">.</span><span class="p">(</span><span class="s2">&quot;Nate&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1"># =&gt; &quot;Je ne sais pas quoi te dire, Nate.&quot;</span>
</span><span class='line'><span class="c1">#    :ok</span>
</span></code></pre></td></tr></table></div></figure>


<p>Comme dans d&#8217;autres langages fonctionnels, plutôt que de reposer sur des
boucles, Elixir utilise énormément la récursivité. Cela dit, le module <code>Enum</code>
fournit quelques fonctions bien connues des rubyists, comme <code>each</code> par exemple.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='elixir'><span class='line'><span class="no">Enum</span><span class="o">.</span><span class="n">each</span><span class="p">([</span><span class="s2">&quot;Joe&quot;</span><span class="p">,</span> <span class="s2">&quot;Matz&quot;</span><span class="p">,</span> <span class="s2">&quot;Jose&quot;</span><span class="p">],</span> <span class="k">fn</span> <span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="no">IO</span><span class="o">.</span><span class="n">puts</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">end</span><span class="p">)</span>
</span><span class='line'><span class="c1"># =&gt; Joe</span>
</span><span class='line'><span class="c1"># =&gt; Matz</span>
</span><span class='line'><span class="c1"># =&gt; Jose</span>
</span><span class='line'><span class="c1"># =&gt; :ok</span>
</span><span class='line'>
</span><span class='line'><span class="k">defmodule</span> <span class="no">RecursionExamples</span> <span class="k">do</span>
</span><span class='line'><span class="k">  def</span> <span class="n">recurse</span><span class="p">([])</span> <span class="k">do</span>
</span><span class='line'><span class="k">    </span><span class="ss">:ok</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">recurse</span><span class="p">([</span><span class="n">head</span><span class="o">|</span><span class="n">tail</span><span class="p">])</span> <span class="k">do</span>
</span><span class='line'><span class="k">    </span><span class="no">IO</span><span class="o">.</span><span class="n">puts</span> <span class="n">head</span>
</span><span class='line'>    <span class="n">recurse</span><span class="p">(</span><span class="n">tail</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="no">RecursionExamples</span><span class="o">.</span><span class="n">recurse</span><span class="p">([</span><span class="s2">&quot;Joe&quot;</span><span class="p">,</span> <span class="s2">&quot;Matz&quot;</span><span class="p">,</span> <span class="s2">&quot;Jose&quot;</span><span class="p">])</span>
</span><span class='line'><span class="c1"># =&gt; Joe</span>
</span><span class='line'><span class="c1"># =&gt; Matz</span>
</span><span class='line'><span class="c1"># =&gt; Jose</span>
</span><span class='line'><span class="c1"># =&gt; :ok</span>
</span></code></pre></td></tr></table></div></figure>


<p>C&#8217;est tout pour cette première partie. À bientôt pour <a href="http://vfsvp.fr/article/elixir-pour-les-rubyists-2">la deuxième</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[6 façons de réduire la souffrance due aux tests fonctionnels avec Rails]]></title>
    <link href="http://vfsvp.fr/article/6-facons-de-reduire-la-souffrance-des-tests-fonctionnels-avec-Rails"/>
    <updated>2013-10-12T13:00:00+02:00</updated>
    <id>http://vfsvp.fr/article/6-facons-de-reduire-la-souffrance-des-tests-fonctionnels-avec-Rails</id>
    <content type="html"><![CDATA[<p>Source: <a href="http://gaslight.co/blog/6-ways-to-remove-pain-from-feature-testing-in-ruby-on-rails">6 Ways to Remove Pain From Feature Testing in Ruby on Rails de Mitch Lloyd</a></p>

<p>L&#8217;écriture des tests fonctionnels a été une des parts les plus douloureuses de
mon travail avec Ruby on Rails. Mais aujourd&#8217;hui c&#8217;est quelque chose que
j&#8217;apprécie et voici pourquoi :</p>

<h2>1. Je n&#8217;utilise pas Cucumber</h2>

<p><strong>Attention:</strong> Le point de vue exprimé dans le paragraphe suivant ne reflète pas
forcement celui de l&#8217;équipe ou des partenaires de Gaslight Software, LLC.</p>

<p>Si vous avez installé Cucumber, supprimez-le. Les tests sont déjà assez
difficiles sans que l&#8217;on ait besoin de transformer le langage naturel en code
Ruby.</p>

<!-- more -->


<p>J&#8217;utilise :</p>

<ul>
<li>Rspec &ndash; DSL spécialisé dans les tests</li>
<li>FactoryGirl &ndash; Constructeur de modèles</li>
<li>Capybara &ndash; DOM Dominator</li>
<li>Database Cleaner - Nettoyeur de bases de données</li>
<li>Spring - Accélérateur de démarrage</li>
</ul>


<p>Et j&#8217;en suis très content. Écrivons une spec.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">feature</span> <span class="s1">&#39;Navigating through workpapers&#39;</span> <span class="k">do</span>
</span><span class='line'>  <span class="n">let</span><span class="p">(</span><span class="ss">:user</span><span class="p">)</span> <span class="p">{</span> <span class="n">create</span><span class="p">(</span><span class="ss">:user</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>  <span class="n">let</span><span class="p">(</span><span class="ss">:audit</span><span class="p">)</span> <span class="p">{</span> <span class="n">create</span><span class="p">(</span><span class="ss">:audit</span><span class="p">,</span> <span class="ss">users</span><span class="p">:</span> <span class="o">[</span><span class="n">user</span><span class="o">]</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">scenario</span> <span class="s2">&quot;User sees workpapers within an audit&quot;</span> <span class="k">do</span>
</span><span class='line'>    <span class="n">workpaper</span> <span class="o">=</span> <span class="n">create</span><span class="p">(</span><span class="ss">:workpaper</span><span class="p">,</span> <span class="ss">audit</span><span class="p">:</span> <span class="n">audit</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">visit</span> <span class="s1">&#39;/&#39;</span>
</span><span class='line'>    <span class="n">fill_in</span> <span class="s1">&#39;email&#39;</span><span class="p">,</span> <span class="ss">with</span><span class="p">:</span> <span class="n">user</span><span class="o">.</span><span class="n">email</span>
</span><span class='line'>    <span class="n">fill_in</span> <span class="s1">&#39;password&#39;</span><span class="p">,</span> <span class="ss">with</span><span class="p">:</span> <span class="s1">&#39;password&#39;</span>
</span><span class='line'>    <span class="n">click_on</span> <span class="s1">&#39;Log In&#39;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">find</span><span class="p">(</span><span class="s1">&#39;#audit-selector&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">select</span> <span class="n">audit</span><span class="o">.</span><span class="n">name</span>
</span><span class='line'>    <span class="n">expect</span><span class="p">(</span><span class="n">page</span><span class="p">)</span><span class="o">.</span><span class="n">to</span> <span class="n">have_css?</span><span class="p">(</span><span class="s1">&#39;.workpaper&#39;</span><span class="p">,</span> <span class="ss">text</span><span class="p">:</span> <span class="n">workpaper</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Tout cela est plutôt pas mal mais une <em>feature</em> un peu plus complexe deviendrait
vite illisible. La logique de connexion va immanquablement être dupliquée entre
plusieurs tests. Même cette <em>feature</em> n&#8217;est pas aussi lisible que je le
souhaiterais.</p>

<h2>2. Utilisez des <em>Page Objects</em></h2>

<p>Les sélecteurs Capybara ont une forte probabilité de casser au fur et à mesure
que le développement avance. Le responsable du contenu décide que le bouton du
formulaire de connexion va maintenant indiquer &ldquo;Connectez-vous à un monde où
tout est possible&rdquo;, vous devez maintenant corriger tous vos tests.</p>

<p>Les <em>page objects</em> sont des interfaces spécifiques à votre DOM. Lorsque le HTML
change, vous saurez exactement où corriger cela dans vos tests.</p>

<p>Voici un <em>page objet</em> &ldquo;page de connexion&#8221; :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">LoginPage</span>
</span><span class='line'>  <span class="kp">include</span> <span class="ss">Capybara</span><span class="p">:</span><span class="ss">:DSL</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">visit_page</span>
</span><span class='line'>    <span class="n">visit</span> <span class="s1">&#39;/&#39;</span>
</span><span class='line'>    <span class="nb">self</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">login</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
</span><span class='line'>    <span class="n">fill_in</span> <span class="s1">&#39;email&#39;</span><span class="p">,</span> <span class="ss">with</span><span class="p">:</span> <span class="n">user</span><span class="o">.</span><span class="n">email</span>
</span><span class='line'>    <span class="n">fill_in</span> <span class="s1">&#39;password&#39;</span><span class="p">,</span> <span class="ss">with</span><span class="p">:</span> <span class="s1">&#39;password&#39;</span>
</span><span class='line'>    <span class="n">click_on</span> <span class="s1">&#39;Log In&#39;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Voici un autre <em>page object</em> &ldquo;index des documents&#8221; :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">WorkpaperIndexPage</span>
</span><span class='line'>  <span class="kp">include</span> <span class="ss">Capybara</span><span class="p">:</span><span class="ss">:DSL</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">select_audit</span><span class="p">(</span><span class="n">audit</span><span class="p">)</span>
</span><span class='line'>    <span class="n">find</span><span class="p">(</span><span class="s1">&#39;#audit-selector&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">select</span> <span class="n">audit</span><span class="o">.</span><span class="n">name</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">has_workpaper?</span><span class="p">(</span><span class="n">workpaper</span><span class="p">)</span>
</span><span class='line'>    <span class="n">has_css?</span><span class="p">(</span><span class="s1">&#39;.workpaper&#39;</span><span class="p">,</span> <span class="ss">text</span><span class="p">:</span> <span class="n">workpaper</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Et voici maintenant un test utilisant ces <em>page objects</em> :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">feature</span> <span class="s1">&#39;Navigating through workpapers&#39;</span> <span class="k">do</span>
</span><span class='line'>  <span class="n">let</span><span class="p">(</span><span class="ss">:user</span><span class="p">)</span> <span class="p">{</span> <span class="n">create</span><span class="p">(</span><span class="ss">:user</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>  <span class="n">let</span><span class="p">(</span><span class="ss">:audit</span><span class="p">)</span> <span class="p">{</span> <span class="n">create</span><span class="p">(</span><span class="ss">:audit</span><span class="p">,</span> <span class="ss">users</span><span class="p">:</span> <span class="o">[</span><span class="n">user</span><span class="o">]</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>  <span class="n">let</span><span class="p">(</span><span class="ss">:login_page</span><span class="p">)</span> <span class="p">{</span> <span class="no">LoginPage</span><span class="o">.</span><span class="n">new</span> <span class="p">}</span>
</span><span class='line'>  <span class="n">let</span><span class="p">(</span><span class="ss">:workpaper_page</span><span class="p">)</span> <span class="p">{</span> <span class="no">WorkpaperIndexPage</span><span class="o">.</span><span class="n">new</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">scenario</span> <span class="s2">&quot;User sees workpapers within an audit&quot;</span> <span class="k">do</span>
</span><span class='line'>    <span class="n">workpaper</span> <span class="o">=</span> <span class="n">create</span><span class="p">(</span><span class="ss">:workpaper</span><span class="p">,</span> <span class="ss">audit</span><span class="p">:</span> <span class="n">audit</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">login_page</span><span class="o">.</span><span class="n">visit_page</span><span class="o">.</span><span class="n">login</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
</span><span class='line'>    <span class="n">workpaper_page</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">audit</span><span class="p">)</span>
</span><span class='line'>    <span class="n">expect</span><span class="p">(</span><span class="n">workpaper_page</span><span class="p">)</span><span class="o">.</span><span class="n">to</span> <span class="n">have_workpaper</span><span class="p">(</span><span class="n">workpaper</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Considérons maintenant que quelqu&#8217;un modifie sans arrêt ce bouton de connexion.
Vous avez simplement à modifier <code>LoginPage</code> et utiliser un ID ou une entrée I18n
(ce qui aurait été une bonne idée dés le départ). Vous n&#8217;avez à vous inquiéter
d&#8217;aucun autre test, tout ce qui concerne cette page est contenu dans ce <em>page
object</em>.</p>

<p>Ces objets sont assez simples mais peuvent tout à fait grossir pour fournir des
fonctionnalités supplémentaires comme la vérification d&#8217;erreurs au fur et à
mesure que l&#8217;utilisateur au travers des pages (ou sections) du site. Le retour
sur investissement des <em>page objects</em> est si rapide que j&#8217;utilise toujours ce
type d&#8217;objet dans mes tests fonctionnels. De la même façon que je n&#8217;écris jamais
de SQL dans mes vues Rails, je n&#8217;accède pas au DOM depuis un test fonctionnel
sans <em>page object</em>.</p>

<h2>3. Créer des messages d&#8217;erreur utiles</h2>

<p>Un test fonctionnel qui échoue peut être difficile à diagnostiquer. Mettons que
vous utilisez un <em>page object</em> comme ceci :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">expect</span><span class="p">(</span><span class="n">workpaper_page</span><span class="p">)</span><span class="o">.</span><span class="n">to</span> <span class="n">have_one_workpaper</span><span class="p">(</span><span class="n">workpaper</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<pre><code>Failure/Error: expect(workpaper_page).to have_one_workpaper(workpaper)
  expected #has_one_workpaper?(workpaper) to return true, got false
</code></pre>

<p>L&#8217;erreur est lisible mais il serait plus facile de savoir si elle est provoquée
par l&#8217;absence du document ou si la présence d&#8217;autres documents.</p>

<p>En général, je lève une exception lorsque j&#8217;appelle ce genre de prédicat sur
un <em>page object</em>.</p>

<pre><code>Failure/Error: expect(workpaper_page).to have_one_workpaper(workpaper)
  PageExpectationNotMetError:
    expected one workpaper called "My Sweet Workpaper", but the following
    workpapers were on the page:
      * "Bogus Workpaper"
      * "My Sweet Workpaper"
</code></pre>

<p>J&#8217;utilise cette technique avec modération et je cherche toujours une approche
plus élégante. Cela me donne tout de même des messages d&#8217;erreur plus précis et
m&#8217;épargne quelques aller-retours avec le navigateur. Faites moi signe si vous
utilisez une autre technique de retour d&#8217;erreur dans vos tests.</p>

<h2>4. Embrassez les tests asynchrones</h2>

<p>Une grande part de la frustration relative aux tests automatisés dans un
navigateur est due aux assertions qui doivent attendre. Ajouter un <code>sleep</code> à vos
tests est passable si vous pensez que l&#8217;un de vos tests a un souci de timing
mais un <code>sleep</code> ne devrait jamais se trouver dans votre code de test final.</p>

<p>Les tests clignotants (ceux qui échouent de façon intermittente) tuent la
confiance que vous avez envers votre suite de tests. Ils devraient être corrigés
ou supprimés.</p>

<p>En général, je conseille surtout de bien apprendre l&#8217;API de Capybara. Voici
quelques pointeurs :</p>

<ul>
<li><code>#all</code> n&#8217;attend pas, ce n&#8217;est dont probablement pas le <em>matcher</em> que vous
cherchez ;</li>
<li>La méthode <code>#has_css?</code> peut prendre un compteur en paramètre de façon à
indiquer combien d&#8217;éléments vous voulez attendre ;</li>
<li>Écrire un test comme <code>expect(page).to_not have_css('.post')</code> est, en général,
une mauvaise idée. Ce matcher attend l&#8217;apparition d&#8217;éléments <code>.post</code> pour
passer ce qui peut engendrer un certain ralentissement. Dans ce genre de cas,
il est préférable d&#8217;utiliser <code>expect(page).to have_no_css('.post')</code> qui
passera immédiatement si les éléments sont absents de la page ou attendra
leur disparition s&#8217;ils sont présents. Dans ce dernier cas, il vaut mieux
s&#8217;assurer de leur présence au préalable.</li>
</ul>


<p>Il peut arriver que vous souhaitiez attendre que quelque chose se produise en
dehors de Capybara. Pour cela, <a href="https://gist.github.com/mattwynne/1228927">ce helper</a>
<code>eventually</code> est très pratique :</p>

<p>Le code suivant attend que le document soit <em>awesome</em> et échoue si ce n&#8217;est pas le cas après deux secondes.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">eventually</span> <span class="p">{</span> <span class="n">expect</span><span class="p">(</span><span class="n">workpaper</span><span class="p">)</span><span class="o">.</span><span class="n">to</span> <span class="n">be_awesome</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Quand pourriez-vous avoir besoin de ce type d&#8217;assertion en dehors de Capybara ?
Lisez la suite…</p>

<h2>5. Prenez la construction de données au sérieux</h2>

<p>Je me souviens avoir entendu un mantra pour les tests fonctionnels qui disait
&ldquo;Tout faire du point de vue de l&#8217;utilisateur&rdquo;. Ce conseil visait à l&#8217;origine à
décourager les testeurs de manipuler les données directement dans les tests
fonctionnels. Je peux vous assurer que c&#8217;était un mauvais conseil. Il est juste
impensable d&#8217;inscrire un utilisateur et de passer au travers de vingt autres
étapes simplement pour le faire cliquer sur un bouton.</p>

<p>J&#8217;utilise beaucoup FactoryGirl pour mettre en place mes données de test. Cela
signifie que j&#8217;ai des factories permettant de générer des objets complexes.
Voici, par exemple, comment faire un document avec un workflow ayant des étapes
assignées à certains utilisateurs appelés <code>preparers</code> et <code>reviewers</code>.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">FactoryGirl</span><span class="o">.</span><span class="n">define</span> <span class="k">do</span>
</span><span class='line'>  <span class="n">factory</span> <span class="ss">:workpaper</span> <span class="k">do</span>
</span><span class='line'>    <span class="n">sequence</span><span class="p">(</span><span class="ss">:name</span><span class="p">)</span> <span class="p">{</span><span class="o">|</span><span class="n">n</span><span class="o">|</span> <span class="s2">&quot;workpaper </span><span class="si">#{</span><span class="n">n</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">factory</span> <span class="ss">:assigned_workpaper</span> <span class="k">do</span>
</span><span class='line'>      <span class="n">ignore</span> <span class="k">do</span>
</span><span class='line'>        <span class="n">preparer</span> <span class="p">{</span> <span class="n">create</span><span class="p">(</span><span class="ss">:user</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>        <span class="n">reviewer</span> <span class="p">{</span> <span class="n">create</span><span class="p">(</span><span class="ss">:user</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>      <span class="n">after</span><span class="p">(</span><span class="ss">:create</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">workpaper</span><span class="p">,</span> <span class="n">evaluator</span><span class="o">|</span>
</span><span class='line'>        <span class="n">create</span><span class="p">(</span><span class="ss">:assigned_workflow</span><span class="p">,</span> <span class="ss">workpaper</span><span class="p">:</span> <span class="n">workpaper</span><span class="p">,</span> <span class="ss">preparer</span><span class="p">:</span> <span class="n">evaluator</span><span class="o">.</span><span class="n">preparer</span><span class="p">,</span> <span class="ss">reviewer</span><span class="p">:</span> <span class="n">evaluator</span><span class="o">.</span><span class="n">reviewer</span><span class="p">)</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">factory</span> <span class="ss">:workflow</span> <span class="k">do</span>
</span><span class='line'>    <span class="n">factory</span> <span class="ss">:assigned_workflow</span> <span class="k">do</span>
</span><span class='line'>      <span class="n">ignore</span> <span class="k">do</span>
</span><span class='line'>        <span class="n">preparer</span> <span class="p">{</span> <span class="n">create</span><span class="p">(</span><span class="ss">:user</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>        <span class="n">reviewer</span> <span class="kp">false</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>      <span class="n">after</span><span class="p">(</span><span class="ss">:create</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">workflow</span><span class="p">,</span> <span class="n">evaluator</span><span class="o">|</span>
</span><span class='line'>        <span class="n">create</span><span class="p">(</span><span class="ss">:step</span><span class="p">,</span> <span class="ss">workflow</span><span class="p">:</span> <span class="n">workflow</span><span class="p">,</span> <span class="ss">user</span><span class="p">:</span> <span class="n">evaluator</span><span class="o">.</span><span class="n">preparer</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span> <span class="n">evaluator</span><span class="o">.</span><span class="n">reviewer</span>
</span><span class='line'>          <span class="n">create</span><span class="p">(</span><span class="ss">:step</span><span class="p">,</span> <span class="ss">workflow</span><span class="p">:</span> <span class="n">workflow</span><span class="p">,</span> <span class="ss">user</span><span class="p">:</span> <span class="n">evaluator</span><span class="o">.</span><span class="n">reviewer</span><span class="p">)</span>
</span><span class='line'>        <span class="k">end</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">factory</span> <span class="ss">:step</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Cela me permet de créer de façon déclarative des objets spécifiques à mes tests.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">create</span><span class="p">(</span><span class="ss">:assigned_workpaper</span><span class="p">,</span> <span class="ss">preparer</span><span class="p">:</span> <span class="n">first_user</span><span class="p">,</span> <span class="ss">reviewer</span><span class="p">:</span> <span class="n">second_user</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Je crée toujours des instances de mes modèles via FactoryGirl dans mes tests
fonctionnels. Je suis fan de FactoryGirl mais je pense qu&#8217;il est possible de
faire encore mieux en ce qui concerne la construction de données complexes comme
celles-ci. Quel que soit l&#8217;outil utilisé, la mise en place des données de test
doit toujours être lisible et facilement exploitable.</p>

<p>Il est non seulement acceptable de mettre en place des données avant de
commencer vos tests mais il est également acceptable de vérifier les effets de
bord qui ne sont pas nécessairement visibles par l&#8217;utilisateur. Dans le monde
des applications en client riche par exemple, voir quelque chose à l&#8217;écran ne
signifie pas forcement que tout a été sauvegardé en base de données.</p>

<p>Tout comme nous avons des helpers pour construire nos données, nous devrions
avoir des helpers pour les inspecter. Ce test va s&#8217;assurer que le <em>preparer</em>
d&#8217;un document a été sauvegardé en base de données :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">eventually</span> <span class="p">{</span> <span class="n">preparer_for</span><span class="p">(</span><span class="n">workpaper</span><span class="p">)</span><span class="o">.</span><span class="n">should</span> <span class="n">be</span><span class="p">(</span><span class="n">preparer</span><span class="p">)</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>6. Créez moins de tests, affinez ceux existant</h2>

<p>Lorsque j&#8217;ai commencé à écrire des tests fonctionnels avec Rails, on m&#8217;a donné
le conseil suivant &ldquo;chaque test doit contenir une action et une assertion&rdquo;. J&#8217;ai
donc travaillé comme ceci :</p>

<ul>
<li>Écrire un scénario cucumber pour une fonctionnalité</li>
<li>Faire fonctionner le code</li>
<li>Écrire un scénario cucumber pour un autre aspect de la fonctionnalité</li>
<li>Faire fonctionner le code</li>
</ul>


<p>C&#8217;est une bonne méthodologie pour les tests unitaires mais c&#8217;est une mauvaise
idée en ce qui concerne les tests fonctionnels.</p>

<p>Prenons le test suivant :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">scenario</span> <span class="s2">&quot;assigning a reviewer to a workpaper&quot;</span> <span class="k">do</span>
</span><span class='line'>  <span class="n">user_visits_workpaper</span><span class="p">(</span><span class="n">user</span><span class="p">,</span> <span class="n">workpaper</span><span class="p">)</span>
</span><span class='line'>  <span class="n">ui</span><span class="o">.</span><span class="n">begin_assigning_reviewer</span>
</span><span class='line'>  <span class="n">ui</span><span class="o">.</span><span class="n">assign_work_to</span><span class="p">(</span><span class="n">reviewer</span><span class="p">)</span>
</span><span class='line'>  <span class="n">eventually</span> <span class="p">{</span> <span class="n">expect</span><span class="p">(</span><span class="n">reviewer_for</span> <span class="n">workpaper</span><span class="p">)</span><span class="o">.</span><span class="n">to</span> <span class="n">eq</span><span class="p">(</span><span class="n">other_tester</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Lorsque l&#8217;on appelle <code>ui.begin_assigning_reviewer</code> une boite de dialogue
s&#8217;ouvre pour permettre à l&#8217;utilisateur de choisir qui qui sera le <code>reviewer</code>.
Cette fonctionnalité marche. Très bien.</p>

<p>Je veux maintenant m&#8217;assurer que le seuls les utilisateurs ayant le droit de
faire des relectures soient listés. Plutôt que de créer un nouveau test, je vais
affiner celui que je viens d&#8217;écrire :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">scenario</span> <span class="s2">&quot;assigning a reviewer to a workpaper&quot;</span> <span class="k">do</span>
</span><span class='line'>  <span class="n">user_visits_workpaper</span><span class="p">(</span><span class="n">user</span><span class="p">,</span> <span class="n">workpaper</span><span class="p">)</span>
</span><span class='line'>  <span class="n">ui</span><span class="o">.</span><span class="n">begin_assigning_reviewer</span>
</span><span class='line'>  <span class="n">expect</span><span class="p">(</span><span class="n">ui</span><span class="p">)</span><span class="o">.</span><span class="n">to</span> <span class="n">have_excluded_user</span><span class="p">(</span><span class="n">non_reviewer</span><span class="p">)</span>
</span><span class='line'>  <span class="n">ui</span><span class="o">.</span><span class="n">assign_work_to</span><span class="p">(</span><span class="n">reviewer</span><span class="p">)</span>
</span><span class='line'>  <span class="n">eventually</span> <span class="p">{</span> <span class="n">expect</span><span class="p">(</span><span class="n">reviewer_for</span> <span class="n">workpaper</span><span class="p">)</span><span class="o">.</span><span class="n">to</span> <span class="n">eq</span><span class="p">(</span><span class="n">other_tester</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Je n&#8217;utiliserais bien sûr pas cette technique pour les tests unitaires mais elle
est efficace pour les tests fonctionnels dont le but est de guider votre
progression et détecter les régressions.</p>

<h2>Mais qui teste vos tests ?</h2>

<p>Lorsque vos tests commencent à contenir beaucoup de logique, quelqu&#8217;un va finir
par vous dire &ldquo;Mais qui teste vos tests ?&rdquo; pour vous signifier que vos tests
sont trop compliqués, trop complexes. Votre code de production teste vos tests.
Ce n&#8217;est pas pour autant une excuse pour écrire de mauvais tests ou des tests
illisibles.</p>

<p>Les outils et techniques cités ci-dessus vont changer au fur et à mesure que le
temps passe mais j&#8217;ai augmenté ma sensibilité aux mauvais tests fonctionnels
pour toujours. Refactorez de façon agressive, concevez intelligemment et aimez
vos tests fonctionnels.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les méthodes pack et unpack en Ruby]]></title>
    <link href="http://vfsvp.fr/article/les-methodes-pack-et-unpack-en-ruby"/>
    <updated>2013-10-07T10:00:00+02:00</updated>
    <id>http://vfsvp.fr/article/les-methodes-pack-et-unpack-en-ruby</id>
    <content type="html"><![CDATA[<p>Source: <a href="http://blog.bigbinary.com/2011/07/20/ruby-pack-unpack.html">Ruby Pack Unpack de Neeraj Singh sur le blog de BigBinary</a></p>

<p>Le langage C permet aux développeurs d&#8217;accéder directement à la mémoire où sont
stockées les variables. Ruby ne le permet pas. Il est cependant des cas dans
lesquels on peut avoir besoin d&#8217;accéder aux bits et octets contenus dans cette
mémoire tout en travaillant avec Ruby. Ce dernier fournit deux méthods <code>pack</code> et
<code>unpack</code> pour cela.</p>

<p>Voici un exemple :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="s1">&#39;A&#39;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;b*&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; [&quot;10000010&quot;]</span>
</span></code></pre></td></tr></table></div></figure>




<!-- more -->


<p>Dans le cas ci-dessus, <code>'A'</code> est une chaîne de caractères stockée et, grâce à
<code>unpack</code> je tente d&#8217;en lire la valeur binaire. La table ASCII indique que la
valeur de <code>'A'</code> est 65 et la représentation binaire de 65 est <code>10000010</code>.</p>

<p>Un autre exemple :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="s1">&#39;A&#39;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;B*&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; [&quot;01000001&quot;]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Notez bien le changement de résultat entre les deux exemples. Quelle est la
différence entre <code>b*</code> et <code>B*</code> ? Pour le comprendre nous devons d&#8217;abord parler
de <em>MSB</em> et <em>LSB</em>.</p>

<h2>Bit de poids fort et bit de poids faible</h2>

<p>Tous les bits ne sont pas créés égaux. <code>'C'</code> a la valeur ASCII 67. La
représentation binaire de 67 est <code>1000011</code>.</p>

<p>Parlons d&#8217;abord du style <em>MSB</em> (most significant bit, bit de poids fort). Si
vous utilisez le style <em>MSB</em>, et lisez donc de gauche à droite (en lisant tout
le temps de gauche à droite), le bit de poids le plus fort est donc le premier.
Puisque le bit de poids le plus fort vient en premier, nous pouvons ajouter un
<code>0</code> devant pour obtenir huit bits. Après avoir ajouté un <code>0</code> la représentation
binaire est donc <code>01000011</code>.</p>

<p>Pour convertir cette valeur en <em>LSB</em> (least significant bit, bit de poids
faible), nous devons stocker le bit de poids faible en premier (à gauche). Nous
pouvons voir ci-dessous comment les bits vont être déplacés lors de la
convertion de <em>MSB</em> vers <em>LSB</em>. Notez qu&#8217;ici la position 1 indique le bit le
plus à gauche.</p>

<ul>
<li>déplacer la valeur 1 de la position <em>MSB</em> 8 à la position <em>LSB</em> 1</li>
<li>déplacer la valeur 1 de la position <em>MSB</em> 7 à la position <em>LSB</em> 2</li>
<li>déplacer la valeur 0 de la position <em>MSB</em> 6 à la position <em>LSB</em> 3</li>
<li>et ainsi de suite</li>
</ul>


<p>Une fois l&#8217;exercice terminé, la valeur sera <code>11000010</code>.</p>

<p>Nous avons effectué cette transformation à la main pour bien comprendre la
différence entre bit de poids fort et bit de poids faible. La méthode <code>unpack</code>
est cependant capable de donner les deux représentations. Cette méthode peut
prendre <code>b*</code> ou <code>B*</code> en entrée, voici leur différence selon la documentation de
Ruby :</p>

<pre><code>B | bit string (MSB first) | représentation binaire (bit de poids fort en premier)
b | bit string (LSB first) | représentation binaire (bit de poids faible en
</code></pre>

<p>Voyons maintenant deux exemples.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="s1">&#39;C&#39;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;b*&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; [&quot;11000010&quot;]</span>
</span><span class='line'>
</span><span class='line'><span class="s1">&#39;C&#39;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;B*&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; [&quot;01000011&quot;]</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>b*</code> et <code>B*</code> voient tous les deux là même donnée. Ils représentent simplement
cette donnée différemment.</p>

<h2>Différentes façons de représenter une même donnée</h2>

<p>Disons que je souhaite la représentation binaire de la chaîne <code>hello</code>. D&#8217;après
ce que nous avons vu précédemment cela devrait être assez facile :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="s2">&quot;hello&quot;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;B*&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; [&quot;0110100001100101011011000110110001101111&quot;]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Nous pouvons également obtenir le résultat suivant</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="s2">&quot;hello&quot;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;C*&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span><span class="o">|</span><span class="n">e</span><span class="o">|</span> <span class="n">e</span><span class="o">.</span><span class="n">to_s</span> <span class="mi">2</span><span class="p">}</span>
</span><span class='line'><span class="c1">#=&gt; [&quot;1101000&quot;, &quot;1100101&quot;, &quot;1101100&quot;, &quot;1101100&quot;, &quot;1101111&quot;]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Voyons un exemple similaire mais en découpant les étapes cette fois.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="s2">&quot;hello&quot;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;C*&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; [104, 101, 108, 108, 111]</span>
</span></code></pre></td></tr></table></div></figure>


<p>La directive <code>C*</code> retourne les caractères sous la forme d&#8217;un entier non signé
tenant sur 8 bits. On peut voir que la valeur ASCII de <code>h</code> est 104 et celle de
<code>e</code> est 101, etc.</p>

<p>En utilisant la technique vu précédemment, nous pouvons obtenir une
représentation hexadécimale de notre chaîne :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="s2">&quot;hello&quot;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;C*&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span><span class="o">|</span><span class="n">e</span><span class="o">|</span> <span class="n">e</span><span class="o">.</span><span class="n">to_s</span> <span class="mi">16</span><span class="p">}</span>
</span><span class='line'><span class="c1">#=&gt; [&quot;68&quot;, &quot;65&quot;, &quot;6c&quot;, &quot;6c&quot;, &quot;6f&quot;]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Il est toutefois possible d&#8217;obtenir directement cette valeur hexadécimale :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="s2">&quot;hello&quot;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;H*&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; [&quot;68656c6c6f&quot;]</span>
</span></code></pre></td></tr></table></div></figure>


<h2>High nibble first vs Low nibble first</h2>

<p>Observez la différence entre les deux cas suivants :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="s2">&quot;hello&quot;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;H*&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; [&quot;68656c6c6f&quot;]</span>
</span><span class='line'>
</span><span class='line'><span class="s2">&quot;hello&quot;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;h*&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; [&quot;8656c6c6f6&quot;]</span>
</span></code></pre></td></tr></table></div></figure>


<p>La documentation Ruby indique</p>

<pre><code>H | hex string (high nibble first) | représentation hexadécimale (moitié haute en premier)
h | hex string (low nibble first)  | représentation hexadécimale (moitié basse en premier)
</code></pre>

<p>Un octet est composé de 8 bits. Une moitié contient donc 4 bits. Un octet
donc deux moitiés. La valeur ASCII de <code>h</code> est 104. 104 en hexadécimale s&#8217;écrit
68. Ce nombre 68 est stocké en deux moitiés. La première contient la valeur 6
sur 4 bits et la seconde contient la valeur 8. En général on utilise la notation
moitié haute puis moitié basse, de gauche à droite, la valeur 6 pour la
valeur 8.</p>

<p>Si cependant vous devez utiliser la notation moitié basse puis moitié haute, la
valeur 8 prendra la première place suivie de la valeur 6. La notation <em>moitié
basse en premier</em> donne donc 86.</p>

<p>Cette notation est utilisée pour chaque octet. Pour cette raison, la version
<em>moitié basse en premier</em> de <code>68 65 6c 6c 6f</code> est <code>86 56 c6 c6 f6</code>.</p>

<h2>Mélanger les directives</h2>

<p>Dans les exemples précédents, nous avons utilisé le caractère <code>*</code>. Cela indique
de traiter autant de caractères que possible. Par exemple :</p>

<p>A single C will get a single byte.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="s2">&quot;hello&quot;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; [104]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Vous pouvez ajouter plus de <code>C</code> si vous le souhaitez.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="s2">&quot;hello&quot;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;CC&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; [104, 101]</span>
</span><span class='line'>
</span><span class='line'><span class="s2">&quot;hello&quot;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;CCC&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; [104, 101, 108]</span>
</span><span class='line'>
</span><span class='line'><span class="s2">&quot;hello&quot;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;CCCCC&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; [104, 101, 108, 108, 111]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Plutôt que de répéter ces directives, nous pouvons utiliser un nombre pour
indiquer combien de fois la directive doit être répétée.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="s2">&quot;hello&quot;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;C5&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; [104, 101, 108, 108, 111]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Nous pouvons utiliser <code>*</code> pour capturer toutes les octets restants.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="s2">&quot;hello&quot;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;C*&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; [104, 101, 108, 108, 111]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Voyons un exemple dans lequel nous mélangeons les notations <em>MSB</em> et <em>LSB</em> :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="s2">&quot;aa&quot;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;b8B8&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; [&quot;10000110&quot;, &quot;01100001&quot;]</span>
</span></code></pre></td></tr></table></div></figure>


<h2>pack est l&#8217;inverse de unpack</h2>

<p>La méthode <code>pack</code> est utilisée pour lire les données stockées. Voyons quelques
exemples d&#8217;utilisation :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="o">[</span><span class="mi">1000001</span><span class="o">].</span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; &quot;A&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Dans le code ci-dessus, le valeur binaire est interpretée comme un entier non
signé sur 8 bits et le résultat est <code>'A'</code>.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="o">[</span><span class="s1">&#39;A&#39;</span><span class="o">].</span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; &quot;\xA0&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Ici, l&#8217;entrée <code>'A'</code> n&#8217;est pas le <code>A</code> ASCII mais le <code>A</code> hexadécimale. C&#8217;est
la version hexadécimale à cause de la directive <code>H</code>. Cette dernière indique à
<code>pack</code> de traiter l&#8217;entrée comme une valeur hexadécimale. Comme <code>H</code> utilise la
notation <em>moitié haute en premier</em>, puisque l&#8217;entrée ne contient qu&#8217;une moitié,
cela signifie que la deuxième moitié, la moitié basse, a la valeur <code>0</code>. L&#8217;entrée
est donc vue comme <code>'A0'</code>.</p>

<p>Comme la valeur hexadécimale <code>A0</code> ne correspond à rien dans la table ASCII, le
résultat final est laissé tel quel et vaut donc <code>'\xA0'</code>. Le préfix <code>\x</code> indique
qu&#8217;il s&#8217;agit d&#8217;une valeur hexadécimale.</p>

<p>En hexadécimale, <code>a</code> a la même valeur que <code>A</code>. Nous pouvons donc remplacer <code>A</code>
par <code>a</code> dans notre exemple précédent et le résultat reste inchangé. Essayons
pour voir :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="o">[</span><span class="s1">&#39;a&#39;</span><span class="o">].</span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; &quot;\xA0&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Un autre exemple :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="o">[</span><span class="s1">&#39;a&#39;</span><span class="o">].</span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;h&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; &quot;\n&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Dans le code ci-dessus, il y a une différence notable dans le résultat. Nous
avons changé la directive de <code>H</code> à <code>h</code>. Comme <code>h</code> indique d&#8217;utiliser la notation
<em>moitié basse en premier</em> et que l&#8217;entrée ne contient qu&#8217;une moitié, la moitié
basse vaut <code>0</code> et l&#8217;entrée est donc <code>0a</code>. Le résultat est <code>\x0A</code> et si l&#8217;on
regarde dans la table ASCII, <code>0A</code> vaut 10 et le caractère correspondant est
<code>NL</code>, <em>new line</em> soit un saut de ligne. C&#8217;est pour cela que nous voyons
s&#8217;afficher <code>\n</code> qui représente un saut de ligne.</p>

<h2>Utilisation de unpack dans le code de Rails</h2>

<p>J&#8217;ai cherché un peu dans le code source de Rails et trouvé les utilisations
suivantes de la méthode <code>unpack</code> :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">email_address_obfuscated</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;C*&#39;</span><span class="p">)</span>
</span><span class='line'><span class="s1">&#39;mailto:&#39;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;C*&#39;</span><span class="p">)</span>
</span><span class='line'><span class="n">email_address</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;C*&#39;</span><span class="p">)</span>
</span><span class='line'><span class="n">char</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;H2&#39;</span><span class="p">)</span>
</span><span class='line'><span class="n">column</span><span class="o">.</span><span class="n">class</span><span class="o">.</span><span class="n">string_to_binary</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s2">&quot;H*&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">data</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s2">&quot;m&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">s</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s2">&quot;U*&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Nous avons déjà vu les directives <code>C*</code> et <code>H</code>, les directives <code>m</code> et <code>U</code> sont
cependant nouvelles. La première sert à donner une représentation encodée en
base64 de la valeur, la seconde retourne le caractère UTF-8 correspondant. Voici
un exemple :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="s2">&quot;Hello&quot;</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;U*&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; [72, 101, 108, 108, 111]</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Versions de test</h2>

<p>Les exmples de code précédents ont été testés avec la version <em>1.9.2</em> de Ruby.</p>

<p>NDT: J&#8217;ai testé avec les versions 1.9.3 et 2.0.0, les exemples sont toujours
valides.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Utiliser les Expressions Régulières en Ruby (3/3)]]></title>
    <link href="http://vfsvp.fr/article/utiliser-les-expressions-regulieres-en-ruby-3-sur-3"/>
    <updated>2013-10-05T12:00:00+02:00</updated>
    <id>http://vfsvp.fr/article/utiliser-les-expressions-regulieres-en-ruby-3-sur-3</id>
    <content type="html"><![CDATA[<p>Source: <a href="http://www.bluebox.net/about/blog/2013/03/using-regular-expressions-in-ruby-part-3-of-3/">Using Regular Expressions in Ruby de Nell Shamrell sur le blog de Blue Box</a></p>

<p>Voici la seconde partie dans une série sur les Expressions Régulières en Ruby.
Vous pouvez lire la
<a href="http://vfsvp.fr/article/utiliser-les-expressions-regulieres-en-ruby-1-sur-3">première partie ici</a> et la
<a href="http://vfsvp.fr/article/utiliser-les-expressions-regulieres-en-ruby-2-sur-3">deuxième partie ici</a>.</p>

<h2>Le comportement des Expressions Régulières</h2>

<p>Les expressions régulières sont puissantes. Comme un célèbre super-héros l&#8217;a dit
un jour &ldquo;with great power comes great responsibility&rdquo; (à grands pouvoirs,
grande responsabilité). Pour éviter qu&#8217;une expression régulière ne cause une
catastrophe, vous devez être capable d&#8217;en contrôler le comportement.</p>

<!-- more -->


<p>Les expressions régulières ont trois comportements distincts : greedy
(gourmande), lazy (fainéante) et possessive. Ces termes peuvent sembler
négatifs mais ne sont pas pour autant de mauvaises attitudes pour vos
expressions. Ce sont simplement des descriptions des différentes façon d&#8217;agir
que peuvent utiliser vos expressions et que vous pouvez contrôler. Je vais vous
expliquer comment.</p>

<p>Pour comprendre ces comportements, il nous faut d&#8217;abord comprendre les
quantificateurs. Ils permettent de dire au moteur d&#8217;expressions régulières
combien de fois un caractère ou un groupe de caractères doit apparaitre dans
notre chaîne.</p>

<p>Un des quantificateurs que j&#8217;utilise le plus souvent est le <code>+</code>. Lorsque je le
place derrière un caractère, j&#8217;indique que ce dernier doit apparaitre au moins
une fois. Il peut apparaitre autant de fois qu&#8217;il le souhaite mais doit être au
minimum présent une fois.</p>

<p>Prenons l&#8217;expression suivante :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="sr">/.+/</span>
</span></code></pre></td></tr></table></div></figure>


<p>Celle-ci trouverait une correspondance pour tout caractère apparaissant au moins
une fois. Elle garantie donc la présence d&#8217;un caractère dans la chaîne.</p>

<p>Les quantificateurs sont à la base même du comportement de votre expression, à
savoir gourmande, fainéante ou possessive. Par défaut, elle est gourmande.</p>

<p>Un quantificateur gourmand tente de trouver la correspondance la plus longue
possible au sein de la chaîne. Il attrape autant de caractères que ses petites
mains gourmandes le lui permettent et tente de trouver une correspondance. Si
toute la chaîne ne correspond pas, il prend un caractère de moins et tente de
nouveau la recherche. Il recommence ce processus jusqu&#8217;à ce qu&#8217;il ne trouve
plus de caractères à tester.</p>

<p>Les quantificateurs gourmands fournissent un effort maximum pour un retour
maximum. Un quantificateur gourmand essaie autant de cas que possible pour
trouver une correspondance et retourne le maximum de caractères en faisant
partie.</p>

<p>Pour l&#8217;exemple suivant, je vais changer de science fiction et emprunter une
citation de <em>Star Trek: First Contact</em> :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;There&#39;s no time to talk about time we don&#39;t have the time&quot;</span>
</span><span class='line'><span class="sr">/.+time/</span>
</span></code></pre></td></tr></table></div></figure>


<p>Cette expression régulière capture tout caractère apparaissant au moins une
fois, le tout suivi du mot &ldquo;time&rdquo;. Si je fais appel à la méthode <code>match</code> sur
mon expression régulière en lui passant ma chaîne en paramètre :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="sr">/.+time/</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; &quot;There&#39;s no time to talk about time we don&#39;t have the time&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Toute la chaîne correspond.</p>

<p>Lorsque cette expression analyse la chaîne, elle tente d&#8217;abord de trouver la
première partie du modèle, <code>.+</code>. Cela correspond à toute la chaîne. Elle essaie
ensuite de trouver la deuxième partie, le mot <code>time</code>. Comme toute la chaîne a
été consommée, elle cherche &ldquo;time&rdquo; après la fin de cette dernière et ne trouve
rien. Elle recule donc d&#8217;un caractère (<em>backtrack</em>) et retente le test pour
trouver une correspondance. Une fois celle-ci trouvée, elle est retournée. Dans
notre cas, cela représente toute la chaîne.</p>

<p>Les quantificateurs gourmands tentent de faire correspondre toute la chaine puis
reculent progressivement. Ce recule progressif signifie que, si notre chaîne ne
correspond pas du tout au modèle, l&#8217;expression va tenter autant que possible de
trouver une correspondance. Elle doit garder en mémoire les possibilités déjà
tentées ce qui peut prendre beaucoup de ressources systèmes, en particulier
lorsque vous avez plusieurs tests effectués sur un texte long.</p>

<p>Oniguruma a certaines optimisations qui rendent le recule progressif plus
rapide. Patrick Shaughnessy a écrit un fantastique article sur son blog qui
détail comment Oniguruma gère le recul progressif. Malgré les optimisations, une
expression régulière gourmande consommera tout de même beaucoup de ressources.</p>

<p>Lorsque vous souhaitez une recherche plus réduite et qui consomme moins de
ressources, vous devez utiliser un quantificateurs fainéant. Également appelé
quantificateur réticent, celui-ci va commencer sa recherche au tout début
de la chaîne et tenter de faire correspondre le premier caractère. Si cela ne
suffit pas, il va consommer un caractère supplémentaire. En dernier ressort il
tentera de consommer toute la chaîne.</p>

<p>Un quantificateur fainéant fournit l&#8217;effort minimum pour un retour minimum. Il
retourne le moins de caractères possible pour une correspondance. S&#8217;il trouve ce
qu&#8217;il cherche avec le premier caractère de la chaîne, il va simplement retourner
celui-ci. Il est fainéant, il fait le minimum demandé et rien de plus.</p>

<p>Pour utiliser un quantificateur fainéant, il suffit de lui ajouter un point
d&#8217;interrogation.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="sr">/.+?time/</span>
</span></code></pre></td></tr></table></div></figure>


<p>Si j&#8217;appelle la méthode <code>match</code> sur ma chaîne en utilisant un quantificateur
fainéant</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="sr">/.+?time/</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; &quot;There&#39;s no time&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Je récupère seulement &ldquo;There&rsquo;s no time&rdquo;. La recherche a commencé au tout début
de la chaîne et retourne la correspondance minimum. Les expressions régulière
fainéantes utilisent beaucoup moins de recul progressif et, par conséquent,
moins de ressources que les expressions gourmandes.</p>

<p>Comment faire lorsque l&#8217;on souhaite récupérer un maximum de caractères tout en
limitant le recul progressif et la consommation de ressources ? Pour cela, il
existe un troisième quantificateur, le quantificateur possessif. Il fonctionne
sur le principe de tout ou rien, soit il trouve une correspondance au premier
essai soit il échoue. Comme le gourmand, il consomme le plus de caractères possibles (la chaîne entière) et tente la correspondance. Si cette tentative
échoue, il n&#8217;y aura ni recul ni nouvel essai.</p>

<p>Les quantificateurs possessifs utilisent un effort minimum pour un retour
maximum. Ils tentent de retournent autant de caractères que possible en en
faisant le moins possible (ils tentent une fois puis abandonnent).</p>

<p>Pour rendre un quantificateur possessif, il suffit de lui ajouter un plus <code>+</code> :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="sr">/.++time/</span>
</span></code></pre></td></tr></table></div></figure>


<p>Lançons la méthode <code>match</code> sur notre chaîne en lui passant cette expression
possessive :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="sr">/.++time/</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; nil</span>
</span></code></pre></td></tr></table></div></figure>


<p>Cet appel retourne <code>nil</code> car le test a échoué. Pourquoi cet échec ? Il semble
pourtant que notre chaîne corresponde à l&#8217;expression. La raison est qu&#8217;aucun
recul progressif n&#8217;est effectué.</p>

<p>L&#8217;expression va d&#8217;abord tenter de trouver <code>.++</code> ce qui va consommer tout la
chaîne. Lorsqu&#8217;elle tente de trouver le mot <code>time</code>, il ne reste plus de
caractère à consommer. L&#8217;expression ne peut pas reculer à cause du
quantificateur possessif et va donc échouer.</p>

<p>Le principal avantage des quantificateurs possessifs est l&#8217;échec rapide.
L&#8217;absence de recul consomme très peu de ressources. Un quantificateur gourmand
va tenter tout ce qui est possible pour trouver une correspondance. En cas
d&#8217;échec, tout ce travail et toutes ces ressources n&#8217;auront servi à rien. Un
quantificateur possessif évite cela, si aucune correspondance n&#8217;existe l&#8217;échec
sera rapide.</p>

<p>En général, l&#8217;utilisation de quantificateurs possessifs se limite à des
expressions très courte, lorsque vous avez une petite sous-expression au sein
d&#8217;une expression plus large. Ils sont très utiles mais à utiliser avec
précaution.</p>

<h2>Conclusion</h2>

<p>Les expressions régulières peuvent sembler extrêmement complexes. Lorsque j&#8217;ai
appris à aller plus loin que les bases, au delà des petites astuces de
validation d&#8217;email par exemple, j&#8217;ai trouvé que cela m&#8217;aidait de les voir comme
un sous-programme dans un langage différent. En réalité c&#8217;est exactement ça.
Vous écrivez un programme, au sein d&#8217;un autre programme, au sein de Ruby
lui-même.</p>

<p>Comme tout langage de programmation, il est plus simple d&#8217;écrire vos expressions
par petites parties. Lorsque j&#8217;écris un <em>lookbehind</em>, j&#8217;écris d&#8217;abord le modèle
principal, m&#8217;assure qu&#8217;il fonctionne. J&#8217;écris ensuite le modèle du lookbehind,
séparément, et m&#8217;assure qu&#8217;il fonctionne également. Une fois cela fait, je
joins les deux modèles pour valider qu&#8217;ils fonctionnent ensemble.</p>

<p><a href="http://rubular.com/">Rubular</a> est un site fantastic pour écrire et tester vos
expressions régulières. Testez le, utilisez le, il m&#8217;a vraiment facilité la vie.</p>

<p>Comme tout programme informatique, les expressions régulières s&#8217;écrivent en
plusieurs fois. Lorsque vous concevez une expression, il est tout à fait normal
que celle-ci soit laide au début. Faites la fonctionner et après seulement
tentez de la rendre plus lisible. C&#8217;est le même processus rouge, vert,
réusinage (red, green, refector) qui est utilisé dans le développement dirigé
par les tests.</p>

<p>Les expressions régulières sont puissantes. Si puissantes qu&#8217;elles font peur à
beaucoup d&#8217;entre-nous. Cette peur peut être surpassée. Aussi obscures qu&#8217;elle
peuvent paraître, elles ont une structure logique et réfléchie. Utilisez-les,
lancez Rubular et essayez quelques <em>lookaheads</em> et <em>lookbehinds</em>. Tentez les
quantificateurs gourmands, fainéants et possessifs. Explorez la fantastique
intégration des expressions régulières dans Ruby, je pense que vous en serez
surpris ce que vous trouverez.</p>

<h2>L&#8217;auteur chez Blue Box</h2>

<p>Nell Shamrell travaille chez Blue Box en tant qu&#8217;Ingénieur Développement
Logiciel. Elle siège également au conseil de Certification de Programmation
Ruby de l&#8217;Université de Washington et est spécialisée en Ruby, Rails et
Développement Dirigé par les Tests (TDD). Avant le développement, Nell a étudié
et travaillé dans le domaine du théâtre, une excellente préparation à
l&#8217;environnement dynamique de la création d&#8217;applications logicielles. Dans ces
deux mondes, elle s&#8217;efforce de créer une expérience unique. Sur son temps
libre, elle pratique l&#8217;art martial appelé Naginata.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Utiliser les Expressions Régulières en Ruby (2/3)]]></title>
    <link href="http://vfsvp.fr/article/utiliser-les-expressions-regulieres-en-ruby-2-sur-3"/>
    <updated>2013-10-05T12:00:00+02:00</updated>
    <id>http://vfsvp.fr/article/utiliser-les-expressions-regulieres-en-ruby-2-sur-3</id>
    <content type="html"><![CDATA[<p>Source: <a href="http://www.bluebox.net/about/blog/2013/03/using-regular-expressions-in-ruby-part-2-of-3/">Using Regular Expressions in Ruby de Nell Shamrell sur le blog de Blue Box</a></p>

<p>Voici la seconde partie dans une série sur les Expressions Régulières en Ruby.
Vous pouvez lire la
<a href="http://vfsvp.fr/article/utiliser-les-expressions-regulieres-en-ruby-1-sur-3">première partie ici</a> et la
<a href="http://vfsvp.fr/article/utiliser-les-expressions-regulieres-en-ruby-3-sur-3">troisième partie ici</a>.</p>

<h2>Les LookArounds</h2>

<p>Les lookarounds me permettent d&#8217;aller plus loin que la simple comparaison avec
un modèle. En effet, ils offrent la possibilité de donner un contexte à cette
comparaison. Une expression contenant un lookaround ne retourne un résultat que
lorsqu&#8217;elle est effectuée dans ce contexte.</p>

<!-- more -->


<p>Soit une nouvelle chaîne de caractère, une autre citation d&#8217;Obiwan Kenobi dans
Star Wars.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;Who&#39;s the more foolish?  The fool or the fool who follows him?&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Je veux connaître tous les emplacements du mot &ldquo;fool&rdquo; dans cette chaîne. Je vais
donc utiliser l&#8217;expression régulière <code>/fool/</code>. Dans ce cas précis, je vais
utiliser la méthode <code>scan</code> sur ma chaîne. Cette méthode retourne toutes les
occurrences de mon expression dans la chaîne :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">string</span><span class="o">.</span><span class="n">scan</span><span class="p">(</span><span class="sr">/fool/</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; [&quot;fool&quot;, &quot;fool&quot;, &quot;fool&quot;]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Comme on peut le voir, scan retourne une partie du mot &ldquo;foolish&rdquo; et les deux
occurrences du mot &ldquo;fool&rdquo;.</p>

<p>Comment fait-on si l&#8217;on souhaite que notre modèle <code>/fool/</code> retourne un résultat
seulement s&#8217;il fait partie du mot &ldquo;foolish&rdquo; ? Pour ce cas j&#8217;utiliserais un
<em>lookahead positif</em> (recherche vers l&#8217;avant). Cela indique à mon expression
régulière de trouver toutes les correspondances à mon modèle directement suivies
d&#8217;une correspondance à un autre modèle. En Ruby, un lookahead positif est
exprimé grâce à l&#8217;opérateur <code>?=</code> :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="sr">/fool(?=ish)/</span>
</span></code></pre></td></tr></table></div></figure>


<p>Voici mon expression modifiée. Comme vous pouvez le voir, j&#8217;ai mon modèle
contenant le mot &ldquo;fool&rdquo; directement suivi du modèle lookahead &ldquo;ish&rdquo;.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">string</span><span class="o">.</span><span class="n">scan</span><span class="p">(</span><span class="sr">/fool(?=ish)/</span><span class="p">)</span>
</span><span class='line'><span class="o">&gt;=&gt;</span> <span class="o">[</span><span class="s2">&quot;fool&quot;</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Cette fois-ci, la méthode <code>scan</code> retourne un seul résultat, la seule occurrence
de &ldquo;fool&rdquo; suivie de &ldquo;ish&rdquo;.</p>

<p>De nouveau, utilisons la méthode <code>gsub</code> pour modifier notre chaîne. Remplaçons
chaque occurrence de &ldquo;fool&rdquo; (suivie de &ldquo;ish&rdquo;) par le mot &ldquo;self&#8221; :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">string</span><span class="o">.</span><span class="n">gsub</span><span class="p">(</span><span class="sr">/fool(?=ish)/</span><span class="p">,</span> <span class="s2">&quot;self&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; &quot;Who&#39;s the more selfish?  The fool or the fool who follows him?&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Nos excuses à Obiwan Kenobi, nous avons changé la ligne pour <em>&ldquo;Who&rsquo;s the more
selfish?  The fool or the fool who follows him?&rdquo;</em>.</p>

<p>Techniquement, c&#8217;est ce que l&#8217;on appelle une <em>zero-width, positive lookahead
assertion</em> (recherche positive vers l&#8217;avant de taille zéro). Facile à prononcer
n&#8217;est-ce pas ? Dans le livre <em>The Well Grounded Rubyist</em>, David Black
l&#8217;explique comme ceci :</p>

<dl>
<dt>Zero-width</dt>
<dd>   (taille zéro) signifie que le modèle lookahead (&ldquo;ish&rdquo; dans notre cas) ne
   consomme pas de caractères. Cela veut dire que la correspondance est
   cherchée mais n&#8217;est pas retournée. Seule la présence d&#8217;une correspondance
   est retournée, vrai ou faux.</dd>
<dt>Positive</dt>
<dd>   signifie que le modèle doit être présent, obligatoirement.</dd>
<dt>Lookahead</dt>
<dd>   veut dire que cette expression est recherchée après le modèle principal.</dd>
<dt>Assertion</dt>
<dd>   indique que seule la présence d&#8217;une correspondance est retournée sous la
   forme true/false (vrai/faux).</dd>
</dl>

<p>Quelles sont mes autres possibilité ? Si par exemple je souhaite trouver toutes
les occurrences du mot &ldquo;fool&rdquo; qui ne sont <strong>pas</strong> suivies des lettres &ldquo;ish&rdquo; ?
Dans ce cas, je dois utiliser un lookahead négatif. Techniquement, c&#8217;est ce que
l&#8217;on appelle une <em>zero-width, negative lookahead assertion</em> (recherche négative
vers l&#8217;avant de taille zéro). Négative signifie qu&#8217;aucune correspondance à ce
modèle ne doit être trouvée. Pour effectuer un lookahead négatif, uilisez
l&#8217;opérateur <code>?!</code>.</p>

<p>Je vais de nouveau appeler <code>scan</code> sur ma chaîne en utilisant cette fois un
lookahead négatif dans mon expression régulière. Je veux trouver toutes les
occurrences de &ldquo;fool&rdquo; qui ne font pas partie du mot &ldquo;foolish&#8221; :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">string</span><span class="o">.</span><span class="n">scan</span><span class="p">(</span><span class="sr">/fool(?!ish)/</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; [&quot;fool&quot;, &quot;fool&quot;]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Deux correspondances sont retournées, les deux fois où le mot &ldquo;fool&rdquo; apparait
sans faire partie de &ldquo;foolish&rdquo;.</p>

<p>Utilisons maintenant la méthode <code>gsub</code>. À chaque fois que nous
trouvons le mot &ldquo;fool&rdquo; (non suivi des lettres &ldquo;ish&rdquo;), nous allons le remplacer
pas le mot &ldquo;self&#8221; :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">string</span><span class="o">.</span><span class="n">gsub</span><span class="p">(</span><span class="sr">/fool(?!ish)/</span><span class="p">,</span> <span class="s2">&quot;self&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; &quot;Who&#39;s the more foolish?  The self or the self who follows him?&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Encore une fois j&#8217;ai changé une réplique classique. On peut maintenant lire
&ldquo;Who&rsquo;s the more foolish?  The self or the self who follows him?&rdquo;</p>

<p>Les lookaheads sont très pratiques lorsque l&#8217;on souhaite trouver une
correspondance en prenant en compte ce qui la suit. Allons de nouveau un peu
plus loin. Comment dois-je m&#8217;y prendre si je souhaite trouver une correspondance
à partir de ce qui la précède ? Pour faire cela, je dois utiliser une <em>positive
lookbehind assertion</em> (recherche positive vers l&#8217;arrière). Cela signifie que je
veux trouver toutes les correspondances à mon modèle précédées d&#8217;un autre
modèle.</p>

<p>Utilisons une autre citation de Star Wars, une de Yoda cette fois-ci :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;For my ally is the force, and a powerful ally it is.&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>The modèle principal que je souhaite chercher est le mot &ldquo;ally&rdquo;, je vais donc
utiliser l&#8217;expression régulière <code>/ally/</code>. J&#8217;aimerais cependant trouver le mot
&ldquo;ally&rdquo; uniquement s&#8217;il est directement précédé du mot &ldquo;powerful&rdquo;. C&#8217;est le cas
parfait pour un <em>positive lookbehind</em> (recherche positive vers l&#8217;arrière). Les
lookbehinds positifs utilisent l&#8217;opérateur <code>?&lt;=</code>. Utilisons le dans notre
expression régulière :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="sr">/(?&lt;=powerful )ally/</span>
</span></code></pre></td></tr></table></div></figure>


<p>Cette expression régulière relève le mot &ldquo;ally&rdquo; chaque fois qu&#8217;il est
directement précédé du mot &ldquo;powerful&rdquo;. Comme vous pouvez le remarquer, le
lookbehind est positionné avant le modèle principal. Cela montre bien que le mot
&ldquo;powerful&rdquo; doit est devant le mot &ldquo;ally&rdquo;.</p>

<p>Je vais maintenant utiliser la méthode <code>gsub</code> sur ma chaîne. Chaque fois que le
mot &ldquo;ally&rdquo; est précédé par le mot &ldquo;powerful&rdquo;, je veux le remplacer par le mot
&ldquo;friend&#8221; :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">string</span><span class="o">.</span><span class="n">gsub</span><span class="p">(</span><span class="sr">/(?&lt;=powerful )ally/</span><span class="p">,</span> <span class="s2">&quot;friend&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; For my ally is the force, and a powerful friend it is.</span>
</span></code></pre></td></tr></table></div></figure>


<p>Cela change quelque peu les mots de Yoda : &ldquo;For my ally is the force, and a
powerful friend it is.&rdquo;</p>

<p>Comment dois-je m&#8217;y prendre si je souhaite faire le contraire ? Si par exemple
je veux toutes les occurrences du mot &ldquo;ally&rdquo; qui ne sont <strong>pas</strong> précédées du
mot &ldquo;powerful&rdquo;. Dans ce cas, je dois utiliser un <em>negative lookbehind</em>
(recherche négative vers l&#8217;arrière). Pour cela on trouve l&#8217;opérateur <code>?&lt;!</code>.
Utilisons-le dans notre expression régulière :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="sr">/(?&lt;!powerful )ally/</span>
</span></code></pre></td></tr></table></div></figure>


<p>Utilisons maintenant <code>gsub</code> sur notre chaîne pour remplacer chaque occurence du
mot &ldquo;ally&rdquo;, non précédée du mot &ldquo;powerful&rdquo;, par le mot &ldquo;friend&#8221; :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">string</span><span class="o">.</span><span class="n">gsub</span><span class="p">(</span><span class="sr">/(?&lt;!powerful )ally/</span><span class="p">,</span> <span class="s2">&quot;friend&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; &quot;For my friend is the force, and a powerful ally it is.&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>J&#8217;ai de nouveau changé les paroles de Yoda : &ldquo;For my ally is the force, and a
powerful friend it is.&rdquo;.</p>

<p>Les lookarounds donnent une puissance incroyable à vos expressions régulières en
leur apportant un contexte. Plutôt que d&#8217;utiliser un modèle strict qui
correspond ou non, vos expressions régulières deviennent puissantes, flexibles
et capables de trouver bien plus de choses.</p>

<p><a href="http://vfsvp.fr/article/utiliser-les-expressions-regulieres-en-ruby-3-sur-3">Lire le troisième article de cette série</a></p>

<h2>L&#8217;auteur chez Blue Box</h2>

<p>Nell Shamrell travaille chez Blue Box en tant qu&#8217;Ingénieur Développement
Logiciel. Elle siège également au conseil de Certification de Programmation
Ruby de l&#8217;Université de Washington et est spécialisée en Ruby, Rails et
Développement Dirigé par les Tests (TDD). Avant le développement, Nell a étudié
et travaillé dans le domaine du théâtre, une excellente préparation à
l&#8217;environnement dynamique de la création d&#8217;applications logicielles. Dans ces
deux mondes, elle s&#8217;efforce de créer une expérience unique. Sur son temps
libre, elle pratique l&#8217;art martial appelé Naginata.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Utiliser les Expressions Régulières en Ruby (1/3)]]></title>
    <link href="http://vfsvp.fr/article/utiliser-les-expressions-regulieres-en-ruby-1-sur-3"/>
    <updated>2013-10-05T12:00:00+02:00</updated>
    <id>http://vfsvp.fr/article/utiliser-les-expressions-regulieres-en-ruby-1-sur-3</id>
    <content type="html"><![CDATA[<p>Source: <a href="http://www.bluebox.net/about/blog/2013/02/using-regular-expressions-in-ruby-part-1-of-3/">Using Regular Expressions in Ruby de Nell Shamrell sur le blog de Blue Box</a></p>

<p>Voici la première partie d&#8217;une série sur les Expressions Régulières en Ruby.
Vous pouvez lire la
<a href="http://vfsvp.fr/article/utiliser-les-expressions-regulieres-en-ruby-2-sur-3">deuxième partie ici</a> et la
<a href="http://vfsvp.fr/article/utiliser-les-expressions-regulieres-en-ruby-3-sur-3">troisième partie ici</a>.</p>

<h2>Introduction</h2>

<p>Pour être honnête, la première fois que j&#8217;ai vu une expression régulière,
j&#8217;étais intimidée. Cela semblait si cryptique et mystérieux. Je peinais à voir
comment la comprendre et a fortiori en écrire une. Encore récemment, je
n&#8217;utilisais les expressions régulières qu&#8217;en cas d&#8217;absolue nécessité (une
validation d&#8217;email par ici, un remplacement basique par là). Cela m&#8217;a empêché
d&#8217;approfondir ma connaissance de leur utilisation en Ruby. Ruby travaille avec
les expressions régulière dans une harmonie, une symphonie de code. Pour
exploiter pleinement Ruby, je devais surpasser mon intimidation, ma peur des
expressions régulières.</p>

<p>J&#8217;ai dépassé cette peur. Comme toute chose dans la vie, les expressions
régulières semblent insurmontables jusqu&#8217;à ce qu&#8217;on les découpe. Je veux vous
aider à dépasser votre peur des expressions régulières. Pour cela, je vais les
découper, étape par étape, et vous guider au travers du concept d&#8217;expressions
régulières en Ruby et ce jusqu&#8217;aux techniques avancées. J&#8217;espère que vous verrez
la beauté, surpasserez votre intimidation et les adopterez dans votre code.</p>

<!-- more -->


<h2>Les Expressions Régulières</h2>

<p>Une expression régulière est simplement un modèle. Un modèle auquel une chaîne
de caractères correspond ou non. Le livre <em>Programming Ruby 1.9</em> de Dave Thomas
(plus connu sous le nom <em>Pickaxe Book</em> [livre pic-à-glace]) regroupe en trois
catégories ce que l&#8217;on peut faire avec une expression régulière : tester,
extraire et modifier. Vous pouvez tester une chaîne de caractères pour voir si
elle correspond au modèle. Vous pouvez également modifier une chaîne de
caractères en remplaçant les parties correspondant au modèle par un autre texte.
Tester, extraire, modifier. Si simple et à la fois si puissant.</p>

<h2>Les Expressions Régulières en Ruby</h2>

<p>Ruby vous permet de pousser les expressions régulières plus loin. En Ruby, tout
est objet. Cela inclus les expressions régulières. Vous pouvez envoyer des
messages aux objets, vous pouvez donc envoyer des messages aux expressions
régulières. Vous pouvez également les assigner à des variables, les passer à une
méthode et bien plus.</p>

<p>Depuis la version 1.9, Ruby utilise la bibliothèque d&#8217;expressions régulières
Oniguruma. Cette dernière fournit toutes les fonctionnalités standards des
expressions régulières ainsi qu&#8217;un certain nombre d&#8217;extensions. Elle supporte
parfaitement les caractères complexes comme les caractères japonais par exemple.
Une fonctionnalité que j&#8217;apprécie particulièrement est la possibilité d&#8217;utiliser
<code>\h</code> et <code>\H</code> comme raccourcis pour les chiffres hexadécimaux.</p>

<p>J&#8217;ai découvert récemment que Ruby 2.0 utilisait une bibliothèque différente,
Onigmo. Onigmo est un <em>fork</em> d&#8217;Oniguruma et ajoute encore plus de
fonctionnalités exploitables par Ruby. Il sera intéressant de voir jusqu&#8217;où cela
peut aller.</p>

<p>Malgré les modifications apportées par Onigmo, les fondamentaux de l&#8217;utilisation
des expressions régulières ne changent pas. Vous testez vos chaînes de
caractères avec une expression régulière. Vous composez un modèle auquel la
chaîne doit correspondre.</p>

<h2>Test basique</h2>

<p>Dans la plupart des cas en Ruby, j&#8217;utilise l&#8217;opérateur <code>=~</code>. C&#8217;est l&#8217;opérateur
de test basique. Lorsque j&#8217;utilise cet opérateur, je demande à Ruby &ldquo;Est-ce que
cette chaîne de caractères contient ce modèle ?&rdquo;.</p>

<p>Voyons un premier exemple :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="sr">/force/</span> <span class="o">=~</span> <span class="s2">&quot;Use the force&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>À gauche, on trouve une expression régulière qui représente le mot <em>force</em>. À
droite, une citation d&#8217;un de mes films préférés, Star Wars, &ldquo;Use the force&rdquo;.
Lorsque je lance ce code, je demande à Ruby si mon modèle, à gauche, est présent
dans la chaîne de caractères située à droite.</p>

<p>Détail appréciable, je peux en inverser l&#8217;écriture si je le souhaite.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="s2">&quot;Use the force&quot;</span> <span class="o">=~</span> <span class="sr">/force/</span>
</span></code></pre></td></tr></table></div></figure>


<p>Je peux mettre la chaîne à gauche et l&#8217;expression régulière à droite. Je fais le
même travail, simplement formulé autrement, &ldquo;Est-ce que ma chaîne contient mon
expression régulière ?&rdquo;. Certains trouvent cette formulation plus lisible.</p>

<p>Lorsque je lance ce code, il retourne le numéro du caractère auquel la
correspondance commence. Ici, le modèle <code>/force/</code> est trouvé au huitième
caractère de ma chaîne.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="s2">&quot;Use the force&quot;</span> <span class="o">=~</span> <span class="sr">/force/</span>
</span><span class='line'><span class="c1">#=&gt; 8</span>
</span></code></pre></td></tr></table></div></figure>


<p>Je peux également tester si une chaîne <strong>ne contient pas</strong> un modèle en
utilisant l&#8217;opérateur <code>!~</code>. Cela retourne vrai (<em>true</em>) ou faux (<em>false</em>).</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="sr">/dark side/</span> <span class="o">!~</span> <span class="s2">&quot;Use the force&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Si je lance ce code, je demande si l&#8217;expression <code>/dark side/</code> est absente de la
chaîne <code>"Use the force"</code>. Dans le cas présent, vrai est retourné.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="sr">/dark side/</span> <span class="o">!~</span> <span class="s2">&quot;Use the force&quot;</span>
</span><span class='line'><span class="c1">#=&gt; true</span>
</span></code></pre></td></tr></table></div></figure>


<p>Les opérateurs sont parfaits pour la vérification simple, savoir si ma chaîne
correspond à mon expression régulière ou non paer exemple. Ruby fournit
cependant bien plus d&#8217;informations sur la correspondance. Tout ce que j&#8217;ai à
faire, c&#8217;est demander.</p>

<h2>MatchData</h2>

<p>Le secret c&#8217;est de transformer ma correspondance en un objet <code>MatchData</code>. Je
peux créer cet objet avec la méthode <code>match</code>.</p>

<p>Soit la chaîne de caractères suivante :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;The force will be with you always&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Je veux savoir si cette chaîne contient le mot <em>force</em>. Je peux utiliser
l&#8217;expression régulière suivante :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="sr">/force/</span>
</span></code></pre></td></tr></table></div></figure>


<p>J&#8217;appelle la méthode <code>match</code> sur mon expression régulière et lui passe ma
chaîne. Lorsque je lance ce code, il retourne une instance de la classe
<code>MatchData</code> pour ma correspondance.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">my_match</span> <span class="o">=</span> <span class="sr">/force/</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; #&lt;MatchData &quot;force&quot;&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Depuis Ruby 1.9, la correspondance ne se fait plus obligatoirement au début de
la chaîne. Je peux passer un second argument, un entier, qui indique que la
correspondance doit commencer à partir de ce numéro de caractère.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">my_match</span> <span class="o">=</span> <span class="sr">/force/</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; nil</span>
</span></code></pre></td></tr></table></div></figure>


<p>Ici, le code retourne <code>nil</code>. Pour trouver une correspondance au mot <em>force</em>, il
faudrait commencer plus tôt dans la chaîne.</p>

<p>Pour les exemples suivants, je me contenterai de passer simplement ma chaîne de
caractères :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">my_match</span> <span class="o">=</span> <span class="sr">/force/</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
</span><span class='line'><span class="c1">#=&gt; #&lt;MatchData &quot;force&quot;&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>J&#8217;ai accès à des méthodes qui fournissent <strong>bien plus</strong> d&#8217;informations sur ma
correspondance car c&#8217;est maintenant une instance de la classe <code>MatchData</code>.</p>

<p>Si j&#8217;appelle <code>to_s</code> sur ma correspondance, cela va retourner l&#8217;intégralité de
son texte :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">my_match</span><span class="o">.</span><span class="n">to_s</span>
</span><span class='line'><span class="c1">#=&gt; &quot;force&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Si j&#8217;appelle <code>pre_match</code> dessus, cela retourne la partie de ma chaîne qui
<strong>précède</strong> ma correspondance :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">my_match</span><span class="o">.</span><span class="n">pre_match</span>
</span><span class='line'><span class="c1">#=&gt; &quot;The &quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Si j&#8217;appelle <code>post_match</code> dessus, cela retourne la partie de ma chaîne qui
<strong>suit</strong> ma correspondance :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">my_match</span><span class="o">.</span><span class="n">post_match</span>
</span><span class='line'><span class="c1">#=&gt; &quot; will be with you&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Toutes ces méthodes (et il y en a d&#8217;autres) sont bien utiles. <code>MatchData</code>
montre cependant sa réelle utilité lorsque l&#8217;on parle de groupes de captures.
Les groupes de captures sont des sous expressions au sein d&#8217;une expression
régulière. Voici un exemple :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="sr">/(.*)force(.*)/</span>
</span></code></pre></td></tr></table></div></figure>


<p>Pour qu&#8217;une chaîne de caractères contienne cette expression régulière, elle doit
avoir n&#8217;importe quel caractère zéro, une ou plusieurs fois (c&#8217;est la
signification de <code>.*</code>), suivi du mot <em>force</em>, suivi par n&#8217;importe quel caractère
zéro, une ou plusieurs fois.</p>

<p>Notez bien que la première et la dernière partie de l&#8217;expression sont en entre
parenthèses. C&#8217;est ce qu&#8217;on appelle des groupes. Lorsque que je lance ce modèle
sur ma chaîne, ce qui correspond à ces groupes va être mémorisé. Je peux ensuite
accéder à ces groupes et les utiliser dans d&#8217;autres parties de mon code.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">my_match</span> <span class="o">=</span> <span class="sr">/(.*)force(.*)/</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Si je souhaite voir tous ces groupes, mes groupes de captures, je peux appeler
la méthode <code>captures</code> sur ma correspondance.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">my_match</span><span class="o">.</span><span class="n">captures</span>
</span><span class='line'><span class="c1">#=&gt; [&quot;The &quot;, &quot; will be with you always&quot;]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Les objets <code>MatchData</code> sont très proches des tableaux. Je peux accéder à
chaque capture en utilisant les crochets, de la même façon que pour accéder aux
éléments d&#8217;un tableau.</p>

<p>Si j&#8217;appelle <code>my_match[1]</code>, j&#8217;obtiens le premier groupe de capture, <code>"The "</code>.</p>

<p>De la même manière, <code>my_match[2]</code> retourne mon second groupe de captures, <code>"
will be with you always"</code>.</p>

<p>Notez bien que je ne commence pas avec <code>my_match[0]</code> comme je le ferais pour un
tableau classique. Si j&#8217;appelle <code>my_match[0]</code>, plutôt que de récupérer le
premier groupe, j&#8217;obtiens la chaîne sur laquelle j&#8217;ai lancé le modèle.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">my_match</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span>
</span><span class='line'><span class="c1">#=&gt; &quot;The force will be with you always&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Il est important de garder en mémoire que malgré leur ressemblance avec les
tableaux, les objets <code>MatchData</code> ne sont pas des tableaux.</p>

<p>Si j&#8217;essaie d&#8217;appeler une méthode de tableau comme <code>each</code> sur mon objet
<code>MatchData</code>, j&#8217;obtiens une erreur :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">my_match</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">m</span><span class="o">|</span>
</span><span class='line'> <span class="nb">puts</span> <span class="n">m</span><span class="o">.</span><span class="n">upcase</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="c1">#=&gt; NoMethodError</span>
</span></code></pre></td></tr></table></div></figure>


<p>Cependant, je peux facilement corriger cela en convertissant mon objet
<code>MatchData</code> en tableau grâce à la méthode <code>to_a</code>.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">my_match</span><span class="o">.</span><span class="n">to_a</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">m</span><span class="o">|</span>
</span><span class='line'> <span class="nb">puts</span> <span class="n">m</span><span class="o">.</span><span class="n">upcase</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="c1">#=&gt; THE FORCE WILL BE WITH YOU ALWAYS THE WILL BE WITH YOU ALWAYS</span>
</span></code></pre></td></tr></table></div></figure>


<p><a href="http://vfsvp.fr/article/utiliser-les-expressions-regulieres-en-ruby-2-sur-3">Lire le deuxième article de cette série</a></p>

<h2>L&#8217;auteur chez Blue Box</h2>

<p>Nell Shamrell travaille chez Blue Box en tant qu&#8217;Ingénieur Développement
Logiciel. Elle siège également au conseil de Certification de Programmation
Ruby de l&#8217;Université de Washington et est spécialisée en Ruby, Rails et
Développement Dirigé par les Tests (TDD). Avant le développement, Nell a étudié
et travaillé dans le domaine du théâtre, une excellente préparation à
l&#8217;environnement dynamique de la création d&#8217;applications logicielles. Dans ces
deux mondes, elle s&#8217;efforce de créer une expérience unique. Sur son temps
libre, elle pratique l&#8217;art martial appelé Naginata.</p>
]]></content>
  </entry>
  
</feed>
